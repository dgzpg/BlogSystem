CREATE DATABASE  IF NOT EXISTS `blogsystem` /*!40100 DEFAULT CHARACTER SET utf8mb4 */;
USE `blogsystem`;
-- MySQL dump 10.13  Distrib 5.7.17, for Win64 (x86_64)
--
-- Host: localhost    Database: blogsystem
-- ------------------------------------------------------
-- Server version	5.7.20-log

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Table structure for table `admin`
--

DROP TABLE IF EXISTS `admin`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `admin` (
  `admin_id` bigint(20) NOT NULL AUTO_INCREMENT,
  `count_id` varchar(255) DEFAULT NULL,
  `password` varchar(255) DEFAULT NULL,
  `picture_path` varchar(255) DEFAULT NULL,
  `status` int(11) NOT NULL,
  PRIMARY KEY (`admin_id`)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `admin`
--

LOCK TABLES `admin` WRITE;
/*!40000 ALTER TABLE `admin` DISABLE KEYS */;
INSERT INTO `admin` VALUES (1,'2','3','3',1);
/*!40000 ALTER TABLE `admin` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `blog`
--

DROP TABLE IF EXISTS `blog`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `blog` (
  `blog_id` bigint(20) NOT NULL AUTO_INCREMENT,
  `comment_num` bigint(20) DEFAULT NULL,
  `content` longtext,
  `introduction` varchar(255) DEFAULT NULL,
  `key_word` varchar(255) DEFAULT NULL,
  `page_view` bigint(20) DEFAULT NULL,
  `picture_path` varchar(255) DEFAULT NULL,
  `published_time` varchar(255) DEFAULT NULL,
  `recommend` int(11) DEFAULT NULL,
  `status` int(11) DEFAULT NULL,
  `title` varchar(255) DEFAULT NULL,
  `top` int(11) DEFAULT NULL,
  `type` varchar(255) DEFAULT NULL,
  `type_id` bigint(20) DEFAULT NULL,
  `admin_id` bigint(20) DEFAULT NULL,
  PRIMARY KEY (`blog_id`),
  KEY `FKji1id4009ol1wysbncf6yp6d7` (`type_id`),
  KEY `FKd2y3x5qt7e39qe2rk8oa88omr` (`admin_id`),
  CONSTRAINT `FKd2y3x5qt7e39qe2rk8oa88omr` FOREIGN KEY (`admin_id`) REFERENCES `admin` (`admin_id`),
  CONSTRAINT `FKji1id4009ol1wysbncf6yp6d7` FOREIGN KEY (`type_id`) REFERENCES `blog_type` (`type_id`)
) ENGINE=InnoDB AUTO_INCREMENT=90 DEFAULT CHARSET=utf8mb4;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `blog`
--

LOCK TABLES `blog` WRITE;
/*!40000 ALTER TABLE `blog` DISABLE KEYS */;
INSERT INTO `blog` VALUES (28,0,'<h1 class=\"postTitle\" style=\"background-color: transparent; clear: both; color: rgb(70, 70, 70); float: left; font-size: 15.6px; font-variant-numeric: normal; font-variant-east-asian: normal; font-weight: 700; line-height: 23.4px; margin-bottom: 15px; margin-top: 0px; padding-left: 5px; width: 800.18px;\" id=\"nav1_1\"><a class=\"postTitle2\" id=\"cb_post_title_url\" href=\"https://www.cnblogs.com/rubinshao/p/4949029.html\" style=\"color: rgb(100, 102, 179);\">Java 对象和类</a>\n		</h1><span style=\"background-color: transparent; color: rgb(70, 70, 70); font-family: verdana, &quot;ms song&quot;, Arial, Helvetica, sans-serif; font-size: 12px; font-variant-numeric: normal; font-variant-east-asian: normal;\">\n		</span><div class=\"clear\" style=\"background-color: transparent; color: rgb(70, 70, 70); font-size: 12px; font-variant-numeric: normal; font-variant-east-asian: normal;\"></div><span style=\"background-color: transparent; color: rgb(70, 70, 70); font-family: verdana, &quot;ms song&quot;, Arial, Helvetica, sans-serif; font-size: 12px; font-variant-numeric: normal; font-variant-east-asian: normal;\">\n		</span><div class=\"postBody\" style=\"background-color: transparent; border-bottom: 1px solid rgb(0, 0, 0); color: rgb(57, 57, 57); font-size: 14px; font-variant-numeric: normal; font-variant-east-asian: normal; line-height: 21px; padding: 5px 2px 5px 5px;\">\n			<div class=\"blogpost-body\" id=\"cnblogs_post_body\" style=\"margin-bottom: 20px;\"><p style=\"margin-top: 10px;\">Java作为一种面向对象语言。支持以下基本概念：</p>\n<ul style=\"margin-bottom: 0px; margin-left: 30px; word-break: break-all;\">\n<li style=\"list-style: disc outside none; margin-bottom: 14px;\">多态</li>\n<li style=\"list-style: disc outside none; margin-bottom: 14px;\">继承</li>\n<li style=\"list-style: disc outside none; margin-bottom: 14px;\">封装</li>\n<li style=\"list-style: disc outside none; margin-bottom: 14px;\">抽象</li>\n<li style=\"list-style: disc outside none; margin-bottom: 14px;\">类</li>\n<li style=\"list-style: disc outside none; margin-bottom: 14px;\">对象</li>\n<li style=\"list-style: disc outside none; margin-bottom: 14px;\">实例</li>\n<li style=\"list-style: disc outside none; margin-bottom: 14px;\">方法</li>\n<li style=\"list-style: disc outside none; margin-bottom: 14px;\">消息解析</li>\n</ul>\n<p style=\"margin-top: 10px;\">本节我们重点研究对象和类的概念。</p>\n<ul style=\"margin-bottom: 0px; margin-left: 30px; word-break: break-all;\">\n<li style=\"list-style: disc outside none; margin-bottom: 14px;\"><strong>对象</strong>：对象是类的一个实例，有状态和行为。例如，一条狗是一个对象，它的状态有：颜色、名字、品种；行为有：摇尾巴、叫、吃等。</li>\n<li style=\"list-style: disc outside none; margin-bottom: 14px;\"><strong>类</strong>：类是一个模板，它描述一类对象的行为和状态。</li>\n</ul>\n<hr style=\"margin-bottom: 0px; margin-top: 0px;\">\n<h2 style=\"font-size: 21px; font-weight: 700; line-height: 31.5px; margin-top: 10px;\" id=\"nav1_2\"><a href=\"http://www.codingkit.com/java/java-object-classes.html\" target=\"_blank\" style=\"color: rgb(100, 102, 179); text-decoration-line: underline;\">Java中的对象</a></h2>\n<p style=\"margin-top: 10px;\">&nbsp;</p>\n<p style=\"margin-top: 10px;\">现在让我们深入了解什么是对象。看看周围真实的世界，会发现身边有很多对象，车，狗，人等等。所有这些对象都有自己的状态和行为。</p>\n<p style=\"margin-top: 10px;\">拿一条狗来举例，它的状态有：名字、品种、颜色，行为有：叫、摇尾巴和跑。</p>\n<p style=\"margin-top: 10px;\">对比现实对象和软件对象，它们之间十分相似。</p>\n<p style=\"margin-top: 10px;\">软件对象也有状态和行为。软件对象的状态就是属性，行为通过方法体现。</p>\n<p style=\"margin-top: 10px;\">在软件开发中，方法操作对象内部状态的改变，对象的相互调用也是通过方法来完成。</p>\n<h2 style=\"font-size: 21px; font-weight: 700; line-height: 31.5px; margin-top: 10px;\" id=\"nav1_3\">Java中的类</h2>\n<p style=\"margin-top: 10px;\">类可以看成是创建Java对象的模板。</p>\n<p style=\"margin-top: 10px;\">通过下面一个简单的类来理解下Java中类的定义：</p>\n<p style=\"margin-top: 10px;\">一个类可以包含以下类型变量：</p>\n<ul style=\"margin-bottom: 0px; margin-left: 30px; word-break: break-all;\">\n<li style=\"list-style: disc outside none; margin-bottom: 14px;\"><strong>局部变量</strong>：在方法、构造方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。</li>\n<li style=\"list-style: disc outside none; margin-bottom: 14px;\"><strong>成员变量</strong>：成员变量是定义在类中，方法体之外的变量。这种变量在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问。</li>\n<li style=\"list-style: disc outside none; margin-bottom: 14px;\"><strong>类变量</strong>：类变量也声明在类中，方法体之外，但必须声明为static类型。</li>\n</ul>\n<p style=\"margin-top: 10px;\">一个类可以拥有多个方法，在上面的例子中：barking()、hungry()和sleeping()都是Dog类的方法。</p>\n<hr style=\"margin-bottom: 0px; margin-top: 0px;\">\n<h2 style=\"font-size: 21px; font-weight: 700; line-height: 31.5px; margin-top: 10px;\" id=\"nav1_4\">构造方法</h2>\n<p style=\"margin-top: 10px;\">每个类都有构造方法。如果没有显式地为类定义构造方法，Java编译器将会为该类提供一个默认构造方法。</p>\n<p style=\"margin-top: 10px;\">在创建一个对象的时候，至少要调用一个构造方法。构造方法的名称必须与类同名，一个类可以有多个构造方法。</p>\n<p style=\"margin-top: 10px;\">下面是一个构造方法示例：</p>\n<hr style=\"margin-bottom: 0px; margin-top: 0px;\">\n<h2 style=\"font-size: 21px; font-weight: 700; line-height: 31.5px; margin-top: 10px;\" id=\"nav1_5\">创建对象</h2>\n<p style=\"margin-top: 10px;\">对象是根据类创建的。在Java中，使用关键字new来创建一个新的对象。创建对象需要以下三步：</p>\n<ul style=\"margin-bottom: 0px; margin-left: 30px; word-break: break-all;\">\n<li style=\"list-style: disc outside none; margin-bottom: 14px;\"><strong>声明</strong>：声明一个对象，包括对象名称和对象类型。</li>\n<li style=\"list-style: disc outside none; margin-bottom: 14px;\"><strong>实例化</strong>：使用关键字new来创建一个对象。</li>\n<li style=\"list-style: disc outside none; margin-bottom: 14px;\"><strong>初始化</strong>：使用new创建对象时，会调用构造方法初始化对象。</li>\n</ul>\n<p style=\"margin-top: 10px;\">下面是一个创建对象的例子：</p>\n<p style=\"margin-top: 10px;\">编译并运行上面的程序，会打印出下面的结果：</p>\n<hr style=\"margin-bottom: 0px; margin-top: 0px;\">\n<h2 style=\"font-size: 21px; font-weight: 700; line-height: 31.5px; margin-top: 10px;\" id=\"nav1_6\">访问实例变量和方法</h2>\n<p style=\"margin-top: 10px;\">通过已创建的对象来访问成员变量和成员方法，如下所示：</p>\n<hr style=\"margin-bottom: 0px; margin-top: 0px;\">\n<h2 style=\"font-size: 21px; font-weight: 700; line-height: 31.5px; margin-top: 10px;\" id=\"nav1_7\">源文件声明规则</h2>\n<p style=\"margin-top: 10px;\">在本节的最后部分，我们将学习源文件的声明规则。当在一个源文件中定义多个类，并且还有import语句和package语句时，要特别注意这些规则。</p>\n<ul style=\"margin-bottom: 0px; margin-left: 30px; word-break: break-all;\">\n<li style=\"list-style: disc outside none; margin-bottom: 14px;\">一个源文件中只能有一个public类</li>\n<li style=\"list-style: disc outside none; margin-bottom: 14px;\">一个源文件可以有多个非public类</li>\n<li style=\"list-style: disc outside none; margin-bottom: 14px;\">源文件的名称应该和public类的类名保持一致。例如：源文件中public类的类名是Employee，那么源文件应该命名为Employee.java。</li>\n<li style=\"list-style: disc outside none; margin-bottom: 14px;\">如果一个类定义在某个包中，那么package语句应该在源文件的首行。</li>\n<li style=\"list-style: disc outside none; margin-bottom: 14px;\">如果源文件包含import语句，那么应该放在package语句和类定义之间。如果没有package语句，那么import语句应该在源文件中最前面。</li>\n<li style=\"list-style: disc outside none; margin-bottom: 14px;\">import语句和package语句对源文件中定义的所有类都有效。在同一源文件中，不能给不同的类不同的包声明。</li>\n</ul>\n<p style=\"margin-top: 10px;\">类有若干种访问级别，并且类也分不同的类型：抽象类和final类等。这些将在访问控制章节介绍。</p>\n<p style=\"margin-top: 10px;\">除了上面提到的几种类型，Java还有一些特殊的类，如：内部类、匿名类。</p>\n<hr style=\"margin-bottom: 0px; margin-top: 0px;\">\n<h2 style=\"font-size: 21px; font-weight: 700; line-height: 31.5px; margin-top: 10px;\" id=\"nav1_8\">Java包</h2>\n<p style=\"margin-top: 10px;\">包主要用来对类和接口进行分类。当开发Java程序时，可能编写成百上千的类，因此很有必要对类和接口进行分类。</p>\n<h2 style=\"font-size: 21px; font-weight: 700; line-height: 31.5px; margin-top: 10px;\" id=\"nav1_9\">Import语句</h2>\n<p style=\"margin-top: 10px;\">在Java中，如果给出一个完整的限定名，包括包名、类名，那么Java编译器就可以很容易地定位到源代码或者类。Import语句就是用来提供一个合理的路径，使得编译器可以找到某个类。</p>\n<p style=\"margin-top: 10px;\">例如，下面的命令行将会命令编译器载入java_installation/java/io路径下的所有类</p></div></div>','java类与对象','java；类；对象',9,'http://localhost:9010/picture/2019—01-31 21-45-53.jpg','2019-02-05 01-32-37',2,1,'java类与对象',2,'javaSE ',8,NULL),(29,0,'<h1 class=\"postTitle\" style=\"background-color: transparent; clear: both; color: rgb(70, 70, 70); float: left; font-size: 15.6px; font-variant-numeric: normal; font-variant-east-asian: normal; font-weight: 700; line-height: 23.4px; margin-bottom: 15px; margin-top: 0px; padding-left: 5px; width: 800.18px;\" id=\"nav1_1\"><a class=\"postTitle2\" id=\"cb_post_title_url\" href=\"https://www.cnblogs.com/rubinshao/p/4953559.html\" style=\"color: rgb(255, 102, 0);\">Java 基本数据类型</a>\n		</h1><span style=\"background-color: transparent; color: rgb(70, 70, 70); font-family: verdana, &quot;ms song&quot;, Arial, Helvetica, sans-serif; font-size: 12px; font-variant-numeric: normal; font-variant-east-asian: normal;\">\n		</span><div class=\"clear\" style=\"background-color: transparent; color: rgb(70, 70, 70); font-size: 12px; font-variant-numeric: normal; font-variant-east-asian: normal;\"></div><span style=\"background-color: transparent; color: rgb(70, 70, 70); font-family: verdana, &quot;ms song&quot;, Arial, Helvetica, sans-serif; font-size: 12px; font-variant-numeric: normal; font-variant-east-asian: normal;\">\n		</span><div class=\"postBody\" style=\"background-color: transparent; border-bottom: 1px solid rgb(0, 0, 0); color: rgb(57, 57, 57); font-size: 14px; font-variant-numeric: normal; font-variant-east-asian: normal; line-height: 21px; padding: 5px 2px 5px 5px;\">\n			<div class=\"blogpost-body\" id=\"cnblogs_post_body\" style=\"margin-bottom: 20px;\"><p style=\"margin-top: 10px;\">变量就是申请内存来存储值。也就是说，当创建变量的时候，需要在内存中申请空间。</p>\n<p style=\"margin-top: 10px;\">内存管理系统根据变量的类型为变量分配存储空间，分配的空间只能用来储存该类型数据。</p>\n<p style=\"margin-top: 10px;\">因此，通过定义不同类型的变量，可以在内存中储存整数、小数或者字符。</p>\n<p style=\"margin-top: 10px;\">Java的两大数据类型:</p>\n<ul style=\"margin-bottom: 0px; margin-left: 30px; word-break: break-all;\">\n<li style=\"list-style: disc outside none; margin-bottom: 14px;\">内置数据类型</li>\n<li style=\"list-style: disc outside none; margin-bottom: 14px;\">引用数据类型</li>\n</ul>\n<hr style=\"margin-bottom: 0px; margin-top: 0px;\">\n<h2 style=\"font-size: 21px; font-weight: 700; line-height: 31.5px; margin-top: 10px;\" id=\"nav1_2\">内置数据类型</h2>\n<p style=\"margin-top: 10px;\">Java语言提供了八种基本类型。六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型。</p>\n<p style=\"margin-top: 10px;\">byte：</p>\n<ul style=\"margin-bottom: 0px; margin-left: 30px; word-break: break-all;\">\n<li style=\"list-style: disc outside none; margin-bottom: 14px;\">byte数据类型是8位、有符号的，以二进制补码表示的整数；</li>\n<li style=\"list-style: disc outside none; margin-bottom: 14px;\">最小值是-128（-2^7）；</li>\n<li style=\"list-style: disc outside none; margin-bottom: 14px;\">最大值是127（2^7-1）；</li>\n<li style=\"list-style: disc outside none; margin-bottom: 14px;\">默认值是0；</li>\n<li style=\"list-style: disc outside none; margin-bottom: 14px;\">byte类型用在大型数组中节约空间，主要代替整数，因为byte变量占用的空间只有int类型的四分之一；</li>\n<li style=\"list-style: disc outside none; margin-bottom: 14px;\">例子：byte a = 100，byte b = -50。</li>\n</ul>\n<p style=\"margin-top: 10px;\">short：</p>\n<ul style=\"margin-bottom: 0px; margin-left: 30px; word-break: break-all;\">\n<li style=\"list-style: disc outside none; margin-bottom: 14px;\">short数据类型是16位、有符号的以二进制补码表示的整数</li>\n<li style=\"list-style: disc outside none; margin-bottom: 14px;\">最小值是-32768（-2^15）；</li>\n<li style=\"list-style: disc outside none; margin-bottom: 14px;\">最大值是32767（2^15 - 1）；</li>\n<li style=\"list-style: disc outside none; margin-bottom: 14px;\">Short数据类型也可以像byte那样节省空间。一个short变量是int型变量所占空间的二分之一；</li>\n<li style=\"list-style: disc outside none; margin-bottom: 14px;\">默认值是0；</li>\n<li style=\"list-style: disc outside none; margin-bottom: 14px;\">例子：short s = 1000，short r = -20000。</li>\n</ul>\n<p style=\"margin-top: 10px;\">int：</p>\n<ul style=\"margin-bottom: 0px; margin-left: 30px; word-break: break-all;\">\n<li style=\"list-style: disc outside none; margin-bottom: 14px;\">int数据类型是32位、有符号的以二进制补码表示的整数；</li>\n<li style=\"list-style: disc outside none; margin-bottom: 14px;\">最小值是-2,147,483,648（-2^31）；</li>\n<li style=\"list-style: disc outside none; margin-bottom: 14px;\">最大值是2,147,485,647（2^31 - 1）；</li>\n<li style=\"list-style: disc outside none; margin-bottom: 14px;\">一般地整型变量默认为int类型；</li>\n<li style=\"list-style: disc outside none; margin-bottom: 14px;\">默认值是0；</li>\n<li style=\"list-style: disc outside none; margin-bottom: 14px;\">例子：int a = 100000, int b = -200000。</li>\n</ul>\n<p style=\"margin-top: 10px;\">long：</p>\n<ul style=\"margin-bottom: 0px; margin-left: 30px; word-break: break-all;\">\n<li style=\"list-style: disc outside none; margin-bottom: 14px;\">long数据类型是64位、有符号的以二进制补码表示的整数；</li>\n<li style=\"list-style: disc outside none; margin-bottom: 14px;\">最小值是-9,223,372,036,854,775,808（-2^63）；</li>\n<li style=\"list-style: disc outside none; margin-bottom: 14px;\">最大值是9,223,372,036,854,775,807（2^63 -1）；</li>\n<li style=\"list-style: disc outside none; margin-bottom: 14px;\">这种类型主要使用在需要比较大整数的系统上；</li>\n<li style=\"list-style: disc outside none; margin-bottom: 14px;\">默认值是0L；</li>\n<li style=\"list-style: disc outside none; margin-bottom: 14px;\">例子： long a = 100000L，int b = -200000L。</li>\n</ul>\n<p style=\"margin-top: 10px;\">float：</p>\n<ul style=\"margin-bottom: 0px; margin-left: 30px; word-break: break-all;\">\n<li style=\"list-style: disc outside none; margin-bottom: 14px;\">float数据类型是单精度、32位、符合IEEE 754标准的浮点数；</li>\n<li style=\"list-style: disc outside none; margin-bottom: 14px;\">float在储存大型浮点数组的时候可节省内存空间；</li>\n<li style=\"list-style: disc outside none; margin-bottom: 14px;\">默认值是0.0f；</li>\n<li style=\"list-style: disc outside none; margin-bottom: 14px;\">浮点数不能用来表示精确的值，如货币；</li>\n<li style=\"list-style: disc outside none; margin-bottom: 14px;\">例子：float f1 = 234.5f。</li>\n</ul>\n<p style=\"margin-top: 10px;\">double：</p>\n<ul style=\"margin-bottom: 0px; margin-left: 30px; word-break: break-all;\">\n<li style=\"list-style: disc outside none; margin-bottom: 14px;\">double数据类型是双精度、64位、符合IEEE 754标准的浮点数；</li>\n<li style=\"list-style: disc outside none; margin-bottom: 14px;\">浮点数的默认类型为double类型；</li>\n<li style=\"list-style: disc outside none; margin-bottom: 14px;\">double类型同样不能表示精确的值，如货币；</li>\n<li style=\"list-style: disc outside none; margin-bottom: 14px;\">默认值是0.0f；</li>\n<li style=\"list-style: disc outside none; margin-bottom: 14px;\">例子：double d1 = 123.4。</li>\n</ul>\n<p style=\"margin-top: 10px;\">boolean：</p>\n<ul style=\"margin-bottom: 0px; margin-left: 30px; word-break: break-all;\">\n<li style=\"list-style: disc outside none; margin-bottom: 14px;\">boolean数据类型表示一位的信息；</li>\n<li style=\"list-style: disc outside none; margin-bottom: 14px;\">只有两个取值：true和false；</li>\n<li style=\"list-style: disc outside none; margin-bottom: 14px;\">这种类型只作为一种标志来记录true/false情况；</li>\n<li style=\"list-style: disc outside none; margin-bottom: 14px;\">默认值是false；</li>\n<li style=\"list-style: disc outside none; margin-bottom: 14px;\">例子：boolean one = true。</li>\n</ul>\n<p style=\"margin-top: 10px;\">char：</p>\n<ul style=\"margin-bottom: 0px; margin-left: 30px; word-break: break-all;\">\n<li style=\"list-style: disc outside none; margin-bottom: 14px;\">char类型是一个单一的16位Unicode字符；</li>\n<li style=\"list-style: disc outside none; margin-bottom: 14px;\">最小值是’\\u0000’（即为0）；</li>\n<li style=\"list-style: disc outside none; margin-bottom: 14px;\">最大值是’\\uffff’（即为65,535）；</li>\n<li style=\"list-style: disc outside none; margin-bottom: 14px;\">char数据类型可以储存任何字符；</li>\n<li style=\"list-style: disc outside none; margin-bottom: 14px;\">例子：char letter = ‘A’。</li>\n</ul>\n<h3 style=\"font-size: 16px; font-weight: 700; line-height: 24px; margin-top: 10px;\" id=\"nav1_3\"><br></h3>\n<hr style=\"margin-bottom: 0px; margin-top: 0px;\">\n<h2 style=\"font-size: 21px; font-weight: 700; line-height: 31.5px; margin-top: 10px;\" id=\"nav1_4\">引用类型</h2>\n<ul style=\"margin-bottom: 0px; margin-left: 30px; word-break: break-all;\">\n<li style=\"list-style: disc outside none; margin-bottom: 14px;\">引用类型变量由类的构造函数创建，可以使用它们访问所引用的对象。这些变量在声明时被指定为一个特定的类型，比如Employee、Pubby等。变量一旦声明后，类型就不能被改变了。</li>\n<li style=\"list-style: disc outside none; margin-bottom: 14px;\">对象、数组都是引用数据类型。</li>\n<li style=\"list-style: disc outside none; margin-bottom: 14px;\">所有引用类型的默认值都是null。</li>\n<li style=\"list-style: disc outside none; margin-bottom: 14px;\">一个引用变量可以用来引用与任何与之兼容的类型。</li>\n<li style=\"list-style: disc outside none; margin-bottom: 14px;\">例子：Animal animal = new Animal(“giraffe”)。</li>\n</ul>\n<hr style=\"margin-bottom: 0px; margin-top: 0px;\">\n<h2 style=\"font-size: 21px; font-weight: 700; line-height: 31.5px; margin-top: 10px;\" id=\"nav1_5\">Java常量</h2>\n<p style=\"margin-top: 10px;\">常量就是一个固定值。它们不需要计算，直接代表相应的值。</p>\n<p style=\"margin-top: 10px;\">常量指不能改变的量。 在Java中用final标志，声明方式和变量类似</p>\n<p style=\"margin-top: 10px;\">虽然常量名也可以用小写，但为了便于识别，通常使用大写字母表示常量。</p>\n<p style=\"margin-top: 10px;\">字面量可以赋给任何内置类型的变量。</p>\n<p style=\"margin-top: 10px;\">byte、int、long、和short都可以用十进制、16进制以及8进制的方式来表示。</p>\n<p style=\"margin-top: 10px;\">当使用常量的时候，前缀o表明是8进制，而前缀0x代表16进制。</p>\n<p style=\"margin-top: 10px;\">和其他语言一样，Java的字符串常量也是包含在两个引号之间的字符序列。</p>\n<p style=\"margin-top: 10px;\">字符串常量和字符常量都可以包含任何Unicode字符。</p></div></div>','java基本数据类型','基本数据类型',8,'http://localhost:9010/picture/2019—01-31 21-46-24.jpg','2019-02-05 01-37-28',2,1,'java基本数据类型',2,'javaSE ',8,NULL),(30,0,'<h1 class=\"postTitle\" style=\"background-color: transparent; clear: both; color: rgb(70, 70, 70); float: left; font-size: 15.6px; font-variant-numeric: normal; font-variant-east-asian: normal; font-weight: 700; line-height: 23.4px; margin-bottom: 15px; margin-top: 0px; padding-left: 5px; width: 800.18px;\" id=\"nav1_1\"><a class=\"postTitle2\" id=\"cb_post_title_url\" href=\"https://www.cnblogs.com/rubinshao/p/4972755.html\" style=\"color: rgb(100, 102, 179);\">MongoDB简单介绍</a>\n		</h1><span style=\"background-color: transparent; color: rgb(70, 70, 70); font-family: verdana, &quot;ms song&quot;, Arial, Helvetica, sans-serif; font-size: 12px; font-variant-numeric: normal; font-variant-east-asian: normal;\">\n		</span><div class=\"clear\" style=\"background-color: transparent; color: rgb(70, 70, 70); font-size: 12px; font-variant-numeric: normal; font-variant-east-asian: normal;\"></div><span style=\"background-color: transparent; color: rgb(70, 70, 70); font-family: verdana, &quot;ms song&quot;, Arial, Helvetica, sans-serif; font-size: 12px; font-variant-numeric: normal; font-variant-east-asian: normal;\">\n		</span><div class=\"postBody\" style=\"background-color: transparent; border-bottom: 1px solid rgb(0, 0, 0); color: rgb(57, 57, 57); font-size: 14px; font-variant-numeric: normal; font-variant-east-asian: normal; line-height: 21px; padding: 5px 2px 5px 5px;\">\n			<div class=\"blogpost-body\" id=\"cnblogs_post_body\" style=\"margin-bottom: 20px;\"><div class=\"blog_content\">\n<div class=\"iteye-blog-content-contain\">\n<h2 style=\"font-size: 21px; font-weight: 700; line-height: 31.5px; margin-top: 10px;\" id=\"nav1_2\">什么是MongoDB ?</h2>\n<p style=\"margin-top: 10px;\"><img width=\"269\" height=\"108\" alt=\"\" src=\"\" style=\"border-color: rgb(57, 57, 57); border-style: none; border-image: none 100% / 1 / 0 stretch; height: 0px; max-width: 900px;\"></p>\n<p style=\"margin-top: 10px;\">转载自：<a href=\"http://www.codingkit.com/mongodb/mongodb-intro.html\" style=\"color: rgb(100, 102, 179); text-decoration-line: underline;\">http://www.codingkit.com/mongodb/mongodb-intro.html</a></p>\n<p style=\"margin-top: 10px;\">MongoDB 是由C++语言编写的，是一个基于分布式文件存储的开源数据库系统。</p>\n<p style=\"margin-top: 10px;\">在高负载的情况下，添加更多的节点，可以保证服务器性能。</p>\n<p style=\"margin-top: 10px;\">MongoDB 旨在为WEB应用提供可扩展的高性能数据存储解决方案。</p>\n<p style=\"margin-top: 10px;\">MongoDB 将数据存储为一个文档，数据结构由键值(key=&gt;value)对组成。MongoDB 文档类似于 JSON 对象。字段值可以包含其他文档，数组及文档数组。</p>\n<p style=\"margin-top: 10px;\">&nbsp;</p>\n<h2 style=\"font-size: 21px; font-weight: 700; line-height: 31.5px; margin-top: 10px;\" id=\"nav1_3\">主要特点</h2>\n<ul style=\"margin-bottom: 0px; margin-left: 30px; word-break: break-all;\">\n<li style=\"list-style: disc outside none; margin-bottom: 14px;\">MongoDB的提供了一个面向文档存储，操作起来比较简单和容易。</li>\n<li style=\"list-style: disc outside none; margin-bottom: 14px;\">你可以在MongoDB记录中设置任何属性的索引 (如：FirstName=\"Sameer\",Address=\"8 Gandhi Road\")来实现更快的排序。</li>\n<li style=\"list-style: disc outside none; margin-bottom: 14px;\">你可以通过本地或者网络创建数据镜像，这使得MongoDB有更强的扩展性。</li>\n<li style=\"list-style: disc outside none; margin-bottom: 14px;\">如果负载的增加（需要更多的存储空间和更强的处理能力） ，它可以分布在计算机网络中的其他节点上这就是所谓的分片。</li>\n<li style=\"list-style: disc outside none; margin-bottom: 14px;\">Mongo支持丰富的查询表达式。查询指令使用JSON形式的标记，可轻易查询文档中内嵌的对象及数组。</li>\n<li style=\"list-style: disc outside none; margin-bottom: 14px;\">MongoDb 使用update()命令可以实现替换完成的文档（数据）或者一些指定的数据字段 。</li>\n<li style=\"list-style: disc outside none; margin-bottom: 14px;\">Mongodb中的Map/reduce主要是用来对数据进行批量处理和聚合操作。</li>\n<li style=\"list-style: disc outside none; margin-bottom: 14px;\">Map和Reduce。Map函数调用emit(key,value)遍历集合中所有的记录，将key与value传给Reduce函数进行处理。</li>\n<li style=\"list-style: disc outside none; margin-bottom: 14px;\">Map函数和Reduce函数是使用Javascript编写的，并可以通过db.runCommand或mapreduce命令来执行MapReduce操作。</li>\n<li style=\"list-style: disc outside none; margin-bottom: 14px;\">GridFS是MongoDB中的一个内置功能，可以用于存放大量小文件。</li>\n<li style=\"list-style: disc outside none; margin-bottom: 14px;\">MongoDB允许在服务端执行脚本，可以用Javascript编写某个函数，直接在服务端执行，也可以把函数的定义存储在服务端，下次直接调用即可。</li>\n<li style=\"list-style: disc outside none; margin-bottom: 14px;\">MongoDB支持各种编程语言:RUBY，PYTHON，JAVA，C++，PHP，C#等多种语言。</li>\n<li style=\"list-style: disc outside none; margin-bottom: 14px;\">MongoDB安装简单。</li>\n</ul>\n<p style=\"margin-top: 10px;\">&nbsp;</p>\n<hr style=\"margin-bottom: 0px; margin-top: 0px;\">\n<p style=\"margin-top: 10px;\">历史 2007年10月，MongoDB由10gen团队所发展。2009年2月首度推出。</p>\n<ul style=\"margin-bottom: 0px; margin-left: 30px; word-break: break-all;\">\n<li style=\"list-style: disc outside none; margin-bottom: 14px;\">2012年05月23日，MongoDB2.1 开发分支发布了! 该版本采用全新架构，包含诸多增强。</li>\n<li style=\"list-style: disc outside none; margin-bottom: 14px;\">2012年06月06日，MongoDB 2.0.6 发布，分布式文档数据库。</li>\n<li style=\"list-style: disc outside none; margin-bottom: 14px;\">2013年04月23日，MongoDB 2.4.3 发布，此版本包括了一些性能优化，功能增强以及bug修复。</li>\n<li style=\"list-style: disc outside none; margin-bottom: 14px;\">2013年08月20日，MongoDB 2.4.6 发布，是目前最新的稳定版。</li>\n</ul>\n<p style=\"margin-top: 10px;\">&nbsp;</p>\n<hr style=\"margin-bottom: 0px; margin-top: 0px;\">\n<h2 style=\"font-size: 21px; font-weight: 700; line-height: 31.5px; margin-top: 10px;\" id=\"nav1_4\">MongoDB 下载</h2>\n<p style=\"margin-top: 10px;\">你可以在mongodb官网下载该安装包，地址为：<a href=\"http://www.codingkit.com/%20http:/www.mongodb.org/downloads\" target=\"_blank\" style=\"color: rgb(100, 102, 179); text-decoration-line: underline;\"> http://www.mongodb.org/downloads</a>。MonggoDB支持以下平台:</p>\n<ul style=\"margin-bottom: 0px; margin-left: 30px; word-break: break-all;\">\n<li style=\"list-style: disc outside none; margin-bottom: 14px;\">OS X 32-bit</li>\n<li style=\"list-style: disc outside none; margin-bottom: 14px;\">OS X 64-bit</li>\n<li style=\"list-style: disc outside none; margin-bottom: 14px;\">Linux 32-bit</li>\n<li style=\"list-style: disc outside none; margin-bottom: 14px;\">Linux 64-bit</li>\n<li style=\"list-style: disc outside none; margin-bottom: 14px;\">Windows 32-bit</li>\n<li style=\"list-style: disc outside none; margin-bottom: 14px;\">Windows 64-bit</li>\n<li style=\"list-style: disc outside none; margin-bottom: 14px;\">Solaris i86pc</li>\n<li style=\"list-style: disc outside none; margin-bottom: 14px;\">Solaris 64</li>\n</ul>\n<p style=\"margin-top: 10px;\">&nbsp;</p>\n<hr style=\"margin-bottom: 0px; margin-top: 0px;\">\n<h2 style=\"font-size: 21px; font-weight: 700; line-height: 31.5px; margin-top: 10px;\" id=\"nav1_5\">MongoDB 工具</h2>\n<p style=\"margin-top: 10px;\">有几种可用于MongoDB的管理工具。</p>\n<h3 style=\"font-size: 16px; font-weight: 700; line-height: 24px; margin-top: 10px;\" id=\"nav1_6\">监控</h3>\n<p style=\"margin-top: 10px;\">MongoDB提供了网络和系统监控工具Munin，它作为一个插件应用于MongoDB中。</p>\n<p style=\"margin-top: 10px;\">Gangila是MongoDB高性能的系统监视的工具，它作为一个插件应用于MongoDB中。</p>\n<p style=\"margin-top: 10px;\">基于图形界面的开源工具 Cacti, 用于查看CPU负载, 网络带宽利用率,它也提供了一个应用于监控 MongoDB 的插件。</p>\n<h3 style=\"font-size: 16px; font-weight: 700; line-height: 24px; margin-top: 10px;\" id=\"nav1_7\">GUI</h3>\n<ul style=\"margin-bottom: 0px; margin-left: 30px; word-break: break-all;\">\n<li style=\"list-style: disc outside none; margin-bottom: 14px;\">Fang of Mongo – 网页式,由Django和jQuery所构成。</li>\n<li style=\"list-style: disc outside none; margin-bottom: 14px;\">Futon4Mongo – 一个CouchDB Futon web的mongodb山寨版。</li>\n<li style=\"list-style: disc outside none; margin-bottom: 14px;\">Mongo3 – Ruby写成。</li>\n<li style=\"list-style: disc outside none; margin-bottom: 14px;\">MongoHub – 适用于OSX的应用程序。</li>\n<li style=\"list-style: disc outside none; margin-bottom: 14px;\">Opricot – 一个基于浏览器的MongoDB控制台, 由PHP撰写而成。</li>\n<li style=\"list-style: disc outside none; margin-bottom: 14px;\">Database Master — Windows的mongodb管理工具</li>\n<li style=\"list-style: disc outside none; margin-bottom: 14px;\">RockMongo — 最好的PHP语言的MongoDB管理工具，轻量级, 支持多国语言.</li>\n</ul>\n<p style=\"margin-top: 10px;\">&nbsp;</p>\n<hr style=\"margin-bottom: 0px; margin-top: 0px;\">\n<h2 style=\"font-size: 21px; font-weight: 700; line-height: 31.5px; margin-top: 10px;\" id=\"nav1_8\">MongoDB 应用案例</h2>\n<p style=\"margin-top: 10px;\">下面列举一些公司<a href=\"http://www.codingkit.com/mongodb/mongodb-tutorial.html\" style=\"color: rgb(100, 102, 179); text-decoration-line: underline;\">MongoDB</a>的实际应用：</p>\n<ul style=\"margin-bottom: 0px; margin-left: 30px; word-break: break-all;\">\n<li style=\"list-style: disc outside none; margin-bottom: 14px;\">Craiglist上使用MongoDB的存档数十亿条记录。</li>\n<li style=\"list-style: disc outside none; margin-bottom: 14px;\">FourSquare，基于位置的社交网站，在Amazon EC2的服务器上使用MongoDB分享数据。</li>\n<li style=\"list-style: disc outside none; margin-bottom: 14px;\">Shutterfly，以互联网为基础的社会和个人出版服务，使用MongoDB的各种持久性数据存储的要求。</li>\n<li style=\"list-style: disc outside none; margin-bottom: 14px;\">bit.ly, 一个基于Web的网址缩短服务，使用MongoDB的存储自己的数据。</li>\n<li style=\"list-style: disc outside none; margin-bottom: 14px;\">spike.com，一个MTV网络的联营公司， spike.com使用MongoDB的。</li>\n<li style=\"list-style: disc outside none; margin-bottom: 14px;\">Intuit公司，一个为小企业和个人的软件和服务提供商，为小型企业使用MongoDB的跟踪用户的数据。</li>\n<li style=\"list-style: disc outside none; margin-bottom: 14px;\">sourceforge.net，资源网站查找，创建和发布开源软件免费，使用MongoDB的后端存储。</li>\n<li style=\"list-style: disc outside none; margin-bottom: 14px;\">etsy.com ，一个购买和出售手工制作物品网站，使用MongoDB。</li>\n<li style=\"list-style: disc outside none; margin-bottom: 14px;\">纽约时报，领先的在线新闻门户网站之一，使用MongoDB。</li>\n<li style=\"list-style: disc outside none; margin-bottom: 14px;\">CERN，著名的粒子物理研究所，欧洲核子研究中心大型强子对撞机的数据使用MongoDB。</li></ul></div></div></div></div>','MongoDB介绍','MongoDB',7,'http://localhost:9010/picture/2019—01-31 21-46-24.jpg','2019-02-05 01-38-50',2,1,'MongoDB',2,'javaSE ',8,NULL),(31,0,'<h1 class=\"postTitle\" style=\"background-color: transparent; clear: both; color: rgb(70, 70, 70); float: left; font-size: 15.6px; font-variant-numeric: normal; font-variant-east-asian: normal; font-weight: 700; line-height: 23.4px; margin-bottom: 15px; margin-top: 0px; padding-left: 5px; width: 800.18px;\" id=\"nav1_1\"><a class=\"postTitle2\" id=\"cb_post_title_url\" href=\"https://www.cnblogs.com/rubinshao/p/4943465.html\" style=\"color: rgb(100, 102, 179);\">Java 开发环境配置</a>\n		</h1><div class=\"clear\" style=\"background-color: transparent; color: rgb(70, 70, 70); font-size: 12px; font-variant-numeric: normal; font-variant-east-asian: normal;\"></div><p><span style=\"background-color: transparent; color: rgb(70, 70, 70); font-family: verdana, &quot;ms song&quot;, Arial, Helvetica, sans-serif; font-size: 12px; font-variant-numeric: normal; font-variant-east-asian: normal;\">\n		</span><span style=\"background-color: transparent; color: rgb(70, 70, 70); font-family: verdana, &quot;ms song&quot;, Arial, Helvetica, sans-serif; font-size: 12px; font-variant-numeric: normal; font-variant-east-asian: normal;\">\n		</span></p><div class=\"postBody\" style=\"background-color: transparent; border-bottom: 1px solid rgb(0, 0, 0); color: rgb(57, 57, 57); font-size: 14px; font-variant-numeric: normal; font-variant-east-asian: normal; line-height: 21px; padding: 5px 2px 5px 5px;\">\n			<div class=\"blogpost-body\" id=\"cnblogs_post_body\" style=\"margin-bottom: 20px;\"><div class=\"blog_content\" id=\"blog_content\">\n<div class=\"iteye-blog-content-contain\">\n<h2 style=\"font-size: 21px; font-weight: 700; line-height: 31.5px; margin-top: 10px;\" id=\"nav1_2\">window系统安装java</h2>\n<h3 style=\"font-size: 16px; font-weight: 700; line-height: 24px; margin-top: 10px;\" id=\"nav1_3\">下载JDK</h3>\n<p style=\"margin-top: 10px;\">首先我们需要下载java开发工具包JDK，下载地址：<a href=\"http://www.oracle.com/technetwork/java/javase/downloads/index.html\" target=\"_blank\" style=\"color: rgb(100, 102, 179); text-decoration-line: underline;\">http://www.oracle.com/technetwork/java/javase/downloads/index.html</a>，点击如下下载按钮：</p>\n<p style=\"margin-top: 10px;\">下载后JDK的安装根据提示进行，还有安装JDK的时候也会安装JRE，一并安装就可以了。</p>\n<p style=\"margin-top: 10px;\">安装JDK，安装过程中可以自定义安装目录等信息，例如我们选择安装目录为C:\\Program Files\\Java\\jdk1.7.0 。</p>\n<h3 style=\"font-size: 16px; font-weight: 700; line-height: 24px; margin-top: 10px;\" id=\"nav1_4\">配置环境变量</h3>\n<p style=\"margin-top: 10px;\">1.安装完成后，右击\"我的电脑\"，点击\"属性\"；</p>\n<p style=\"margin-top: 10px;\">2.选择\"高级\"选项卡，点击\"环境变量\"；</p>\n<p style=\"margin-top: 10px;\">然后就会出现如下图所示的画面</p>\n<p style=\"margin-top: 10px;\"><img width=\"945\" height=\"594\" class=\"alignnone size-full wp-image-4980\" alt=\"java-download\" src=\"http://www.codingkit.com/wp-content/uploads/2013/12/java-download.jpg\" style=\"border-color: rgb(57, 57, 57); border-style: none; border-image: none 100% / 1 / 0 stretch; height: 30px; max-width: 900px;\"></p>\n<p style=\"margin-top: 10px;\">在\"系统变量\"中设置3项属性，JAVA_HOME,PATH,CLASSPATH(大小写无所谓),若已存在则点击\"编辑\"，不存在则点击\"新建\"。</p>\n<p style=\"margin-top: 10px;\"><img width=\"456\" height=\"443\" class=\"alignnone size-full wp-image-4981\" alt=\"java-setup\" src=\"\" style=\"border-color: rgb(57, 57, 57); border-style: none; border-image: none 100% / 1 / 0 stretch; height: 30px; max-width: 900px;\"></p>\n<p style=\"margin-top: 10px;\">变量设置</p>\n<ul style=\"margin-bottom: 0px; margin-left: 30px; word-break: break-all;\">\n<li style=\"list-style: disc outside none; margin-bottom: 14px;\">变量名：JAVA_HOME</li>\n<li style=\"list-style: disc outside none; margin-bottom: 14px;\">变量值：C:\\Program Files\\Java\\jdk1.7.0</li>\n</ul>\n<p style=\"margin-top: 10px;\">//这里是你JDK的安装路径，可以更换</p>\n<ul style=\"margin-bottom: 0px; margin-left: 30px; word-break: break-all;\">\n<li style=\"list-style: disc outside none; margin-bottom: 14px;\">变量名：CLASSPATH</li>\n<li style=\"list-style: disc outside none; margin-bottom: 14px;\">变量值：.;%JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar; //记得前面有个\".\"</li>\n</ul>\n<ul style=\"margin-bottom: 0px; margin-left: 30px; word-break: break-all;\">\n<li style=\"list-style: disc outside none; margin-bottom: 14px;\">变量名：Path</li>\n<li style=\"list-style: disc outside none; margin-bottom: 14px;\">变量值：%JAVA_HOME%\\bin;%JAVA_HOME%\\jre\\bin;</li>\n</ul>\n<p style=\"margin-top: 10px;\">这是java的环境配置，配置完成后直接启动eclipse，它会自动完成java环境的配置。</p>\n<h3 style=\"font-size: 16px; font-weight: 700; line-height: 24px; margin-top: 10px;\" id=\"nav1_5\">测试JDK是否安装成功</h3>\n<p style=\"margin-top: 10px;\">1、\"开始\"-&gt;;\"运行\"，键入\"cmd\"；</p>\n<p style=\"margin-top: 10px;\">2、键入命令\"java -version\"，\"java\"，\"javac\"几个命令，出现画面，说明环境变量配置成功；</p>\n<p style=\"margin-top: 10px;\"><img width=\"497\" height=\"325\" class=\"alignnone size-full wp-image-4979\" alt=\"java-cmd\" src=\"http://www.codingkit.com/wp-content/uploads/2013/12/java-cmd.jpg\" style=\"border-color: rgb(57, 57, 57); border-style: none; border-image: none 100% / 1 / 0 stretch; height: 30px; max-width: 900px;\"></p>\n<hr style=\"margin-bottom: 0px; margin-top: 0px;\">\n<h2 style=\"font-size: 21px; font-weight: 700; line-height: 31.5px; margin-top: 10px;\" id=\"nav1_6\">Linux，UNIX，Solaris，FreeBSD环境变量设置</h2>\n<p style=\"margin-top: 10px;\">环境变量PATH应该设定为指向Java二进制文件安装的位置。如果设置遇到困难，请参考shell文档。</p>\n<p style=\"margin-top: 10px;\">例如，假设你使用bash作为shell，你可以把下面的内容添加到你的 .bashrc文件结尾: export PATH=/path/to/java:$PATH</p>\n<hr style=\"margin-bottom: 0px; margin-top: 0px;\">\n<h2 style=\"font-size: 21px; font-weight: 700; line-height: 31.5px; margin-top: 10px;\" id=\"nav1_7\">流行JAVA开发工具</h2>\n<p style=\"margin-top: 10px;\">正所谓工欲善其事必先利其器，我们在开发java语言过程中同样需要依款不错的开发工具，目前市场上的IDE很多，本文为大家推荐一下几款java开发工具：</p>\n<ul style=\"margin-bottom: 0px; margin-left: 30px; word-break: break-all;\">\n<li style=\"list-style: disc outside none; margin-bottom: 14px;\"><strong>Notepad++ : </strong>Notepad++ 是在微软视窗环境之下的一个免费的代码编辑器，下载地址：<a href=\"http://notepad-plus-plus.org/\" target=\"_blank\" style=\"color: rgb(100, 102, 179); text-decoration-line: underline;\"> http://notepad-plus-plus.org/</a></li>\n<li style=\"list-style: disc outside none; margin-bottom: 14px;\"><strong>Netbeans:</strong>开源免费的java IDE，下载地址： <a href=\"http://www.netbeans.org/index.html\" target=\"_blank\" style=\"color: rgb(100, 102, 179); text-decoration-line: underline;\">http://www.netbeans.org/index.html</a></li>\n<li style=\"list-style: disc outside none; margin-bottom: 14px;\"><strong>Eclipse:</strong>另一个免费开源的java IDE，下载地址： <a href=\"http://www.codingkit.com/%20http:/www.eclipse.org/\" target=\"_blank\" style=\"color: rgb(100, 102, 179); text-decoration-line: underline;\"> http://www.eclipse.org/</a></li></ul></div></div></div></div>','java开发环境配置','开发环境',6,'http://localhost:9010/picture/2019—01-31 21-45-11.jpg','2019-02-05 01-41-07',2,1,'java开发环境',2,'javaSE ',8,NULL),(32,0,'<h1 style=\"background-color: transparent; border: 0px none rgb(0, 0, 0); color: rgb(0, 0, 0); font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Noto Sans CJK SC&quot;, &quot;WenQuanYi Micro Hei&quot;, Arial, sans-serif; font-size: 25.2px; font-variant-numeric: normal; font-variant-east-asian: normal; font-weight: 700; margin-top: 0px;\" id=\"nav1_1\">Java 封装</h1><hr style=\"background-color: rgb(212, 212, 212); border-color: rgb(212, 212, 212); border-style: none; border-image: none 100% / 1 / 0 stretch; border-top-width: 0px; clear: both; color: rgb(212, 212, 212); font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Noto Sans CJK SC&quot;, &quot;WenQuanYi Micro Hei&quot;, Arial, sans-serif; font-size: 12px; font-variant-numeric: normal; font-variant-east-asian: normal; height: 1px; text-align: center;\"><p style=\"background-color: transparent; border: 0px none rgb(51, 51, 51); color: rgb(51, 51, 51); font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Noto Sans CJK SC&quot;, &quot;WenQuanYi Micro Hei&quot;, Arial, sans-serif; font-variant-numeric: normal; font-variant-east-asian: normal; line-height: 26px; margin-bottom: 0px; word-break: break-all; overflow-wrap: break-word;\">在面向对象程式设计方法中，封装（英语：Encapsulation）是指一种将抽象性函式接口的实现细节部份包装、隐藏起来的方法。\n</p><p style=\"background-color: transparent; border: 0px none rgb(51, 51, 51); color: rgb(51, 51, 51); font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Noto Sans CJK SC&quot;, &quot;WenQuanYi Micro Hei&quot;, Arial, sans-serif; font-variant-numeric: normal; font-variant-east-asian: normal; line-height: 26px; margin-bottom: 0px; word-break: break-all; overflow-wrap: break-word;\">封装可以被认为是一个保护屏障，防止该类的代码和数据被外部类定义的代码随机访问。</p><p style=\"background-color: transparent; border: 0px none rgb(51, 51, 51); color: rgb(51, 51, 51); font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Noto Sans CJK SC&quot;, &quot;WenQuanYi Micro Hei&quot;, Arial, sans-serif; font-variant-numeric: normal; font-variant-east-asian: normal; line-height: 26px; margin-bottom: 0px; word-break: break-all; overflow-wrap: break-word;\">\n要访问该类的代码和数据，必须通过严格的接口控制。</p><p style=\"background-color: transparent; border: 0px none rgb(51, 51, 51); color: rgb(51, 51, 51); font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Noto Sans CJK SC&quot;, &quot;WenQuanYi Micro Hei&quot;, Arial, sans-serif; font-variant-numeric: normal; font-variant-east-asian: normal; line-height: 26px; margin-bottom: 0px; word-break: break-all; overflow-wrap: break-word;\">\n封装最主要的功能在于我们能修改自己的实现代码，而不用修改那些调用我们代码的程序片段。</p><p style=\"background-color: transparent; border: 0px none rgb(51, 51, 51); color: rgb(51, 51, 51); font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Noto Sans CJK SC&quot;, &quot;WenQuanYi Micro Hei&quot;, Arial, sans-serif; font-variant-numeric: normal; font-variant-east-asian: normal; line-height: 26px; margin-bottom: 0px; word-break: break-all; overflow-wrap: break-word;\">\n适当的封装可以让程式码更容易理解与维护，也加强了程式码的安全性。</p><h3 style=\"background-color: transparent; border: 0px none rgb(51, 51, 51); color: rgb(51, 51, 51); font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Noto Sans CJK SC&quot;, &quot;WenQuanYi Micro Hei&quot;, Arial, sans-serif; font-size: 16.8px; font-variant-numeric: normal; font-variant-east-asian: normal; font-weight: 700; margin-bottom: 8px; margin-top: 8px;\" id=\"nav1_2\">封装的优点</h3><ul style=\"background-color: transparent; border: 0px none rgb(51, 51, 51); color: rgb(51, 51, 51); font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Noto Sans CJK SC&quot;, &quot;WenQuanYi Micro Hei&quot;, Arial, sans-serif; font-size: 12px; font-variant-numeric: normal; font-variant-east-asian: normal; line-height: 17.33px; list-style-image: none; list-style-position: outside; margin-bottom: 12px; margin-top: 12px;\">\n\n<li style=\"background-image: url(&quot;http://www.runoob.com/wp-content/themes/runoob/assets/img/bullet.png&quot;); background-position: 0% 0.5em; background-repeat: no-repeat; border: 0px none rgb(51, 51, 51); font-size: 13px; line-height: 19.5px; margin-bottom: 13px; margin-left: 13px; padding-left: 19.5px; word-break: break-all;\"><p style=\"border: 0px none rgb(51, 51, 51); line-height: 26px; margin-bottom: 0px; padding-left: 10px; padding-right: 10px; word-break: break-all; overflow-wrap: break-word;\">\n1. 良好的封装能够减少耦合。</p></li><li style=\"background-image: url(&quot;http://www.runoob.com/wp-content/themes/runoob/assets/img/bullet.png&quot;); background-position: 0% 0.5em; background-repeat: no-repeat; border: 0px none rgb(51, 51, 51); font-size: 13px; line-height: 19.5px; margin-bottom: 13px; margin-left: 13px; padding-left: 19.5px; word-break: break-all;\"><p style=\"border: 0px none rgb(51, 51, 51); line-height: 26px; margin-bottom: 0px; padding-left: 10px; padding-right: 10px; word-break: break-all; overflow-wrap: break-word;\">\n2. 类内部的结构可以自由修改。</p></li><li style=\"background-image: url(&quot;http://www.runoob.com/wp-content/themes/runoob/assets/img/bullet.png&quot;); background-position: 0% 0.5em; background-repeat: no-repeat; border: 0px none rgb(51, 51, 51); font-size: 13px; line-height: 19.5px; margin-bottom: 13px; margin-left: 13px; padding-left: 19.5px; word-break: break-all;\"><p style=\"border: 0px none rgb(51, 51, 51); line-height: 26px; margin-bottom: 0px; padding-left: 10px; padding-right: 10px; word-break: break-all; overflow-wrap: break-word;\">\n3. 可以对成员变量进行更精确的控制。</p></li><li style=\"background-image: url(&quot;http://www.runoob.com/wp-content/themes/runoob/assets/img/bullet.png&quot;); background-position: 0% 0.5em; background-repeat: no-repeat; border: 0px none rgb(51, 51, 51); font-size: 13px; line-height: 19.5px; margin-bottom: 13px; margin-left: 13px; padding-left: 19.5px; word-break: break-all;\"><p style=\"border: 0px none rgb(51, 51, 51); line-height: 26px; margin-bottom: 0px; padding-left: 10px; padding-right: 10px; word-break: break-all; overflow-wrap: break-word;\">\n4. 隐藏信息，实现细节。</p></li></ul><hr style=\"background-color: rgb(212, 212, 212); border-color: rgb(212, 212, 212); border-style: none; border-image: none 100% / 1 / 0 stretch; border-top-width: 0px; clear: both; color: rgb(212, 212, 212); font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Noto Sans CJK SC&quot;, &quot;WenQuanYi Micro Hei&quot;, Arial, sans-serif; font-size: 12px; font-variant-numeric: normal; font-variant-east-asian: normal; height: 1px; text-align: center;\"><h2 style=\"background-color: transparent; border: 0px none rgb(51, 51, 51); color: rgb(51, 51, 51); font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Noto Sans CJK SC&quot;, &quot;WenQuanYi Micro Hei&quot;, Arial, sans-serif; font-size: 21.6px; font-variant-numeric: normal; font-variant-east-asian: normal; font-weight: 700; line-height: 38.88px; margin-bottom: 2px; margin-top: 2px;\" id=\"nav1_3\">实现Java封装的步骤</h2><p style=\"background-color: transparent; border: 0px none rgb(51, 51, 51); color: rgb(51, 51, 51); font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Noto Sans CJK SC&quot;, &quot;WenQuanYi Micro Hei&quot;, Arial, sans-serif; font-variant-numeric: normal; font-variant-east-asian: normal; line-height: 26px; margin-bottom: 0px; word-break: break-all; overflow-wrap: break-word;\">1. 修改属性的可见性来限制对属性的访问（一般限制为private）<span style=\"background-color: transparent;\">这段代码中，将 </span><strong style=\"background-color: transparent; border: 0px none rgb(51, 51, 51);\">name</strong><span style=\"background-color: transparent;\"> 和 </span><strong style=\"background-color: transparent; border: 0px none rgb(51, 51, 51);\">age</strong><span style=\"background-color: transparent;\"> 属性设置为私有的，只能本类才能访问，其他类都访问不了，如此就对信息进行了隐藏。</span></p><p style=\"background-color: transparent; border: 0px none rgb(51, 51, 51); color: rgb(51, 51, 51); font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Noto Sans CJK SC&quot;, &quot;WenQuanYi Micro Hei&quot;, Arial, sans-serif; font-variant-numeric: normal; font-variant-east-asian: normal; line-height: 26px; margin-bottom: 0px; word-break: break-all; overflow-wrap: break-word;\">2. 对每个值属性提供对外的公共方法访问，也就是创建一对赋取值方法，用于对私有属性的访问，<span style=\"background-color: transparent;\">采用 </span><strong style=\"background-color: transparent; border: 0px none rgb(51, 51, 51);\">this</strong><span style=\"background-color: transparent;\"> 关键字是为了解决实例变量（private String name）和局部变量（setName(String name)中的name变量）之间发生的同名的冲突。</span></p>','java封装','封装',5,'http://localhost:9010/picture/2019—01-31 21-45-53.jpg','2019-02-05 01-51-52',2,1,'java封装',2,'javaSE ',8,NULL),(33,0,'<h1 class=\"postTitle\" style=\"background-color: transparent; border-bottom: 1px solid rgb(153, 153, 153); border-left: 5px solid rgb(31, 166, 230); clear: both; color: rgb(0, 0, 0); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 15.6px; font-variant-numeric: normal; font-variant-east-asian: normal; font-weight: 700; line-height: 23.4px; margin-bottom: 0px; margin-top: 0px; padding-bottom: 10px; padding-left: 5px; padding-right: 100px;\" id=\"nav1_1\"><a class=\"postTitle2\" id=\"cb_post_title_url\" href=\"https://www.cnblogs.com/voidchar/p/10351554.html\" style=\"color: rgb(28, 119, 145);\">java 中文乱码</a>\n		</h1><span style=\"background-color: transparent; color: rgb(0, 0, 0); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 12px; font-variant-numeric: normal; font-variant-east-asian: normal;\">\n		</span><div class=\"clear\" style=\"background-color: transparent; color: rgb(0, 0, 0); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 12px; font-variant-numeric: normal; font-variant-east-asian: normal;\"></div><span style=\"background-color: transparent; color: rgb(0, 0, 0); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 12px; font-variant-numeric: normal; font-variant-east-asian: normal;\">\n		</span><div class=\"postBody\" style=\"background-color: transparent; border-bottom: 1px solid rgb(0, 0, 0); color: rgb(0, 0, 0); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 12px; font-variant-numeric: normal; font-variant-east-asian: normal; line-height: 21.6px; padding: 5px 2px 5px 5px;\">\n			<div class=\"blogpost-body\" id=\"cnblogs_post_body\" style=\"margin-bottom: 20px;\"><p style=\"margin-top: 10px;\">1、在myeclipse中可以设置文件的编码格式，但是当我们使用Scanner进行键入时，由于Windows使用的是GBK编码，所以如果设置的编码格式不是GBK的话会出现中文乱码问题。</p>\n<p style=\"margin-top: 10px;\">2、前台页面向后台发送请求时如果是get方式，会默认以ISO8859-1格式发送，同样会出现中文乱码。</p>\n<p style=\"margin-top: 10px;\">3、对于以上两种情况，均可以使用以下代码解决</p>\n<div class=\"cnblogs_code\" style=\"background-color: rgb(245, 245, 245); border: 1px solid rgb(204, 204, 204); font-family: &quot;Courier New&quot;; margin-bottom: 5px; margin-top: 5px; overflow: auto; padding: 5px;\">\n<pre style=\"font-family: &quot;Courier New&quot;; font-size: 12px; margin-bottom: 0px; padding: 0px;\" class=\"hljs javascript\"><span style=\"color: rgb(0, 128, 128); line-height: 18px;\"><span class=\"hljs-number\">1</span></span> <span style=\"color: rgb(0, 0, 255); line-height: 18px;\"><span class=\"hljs-keyword\">new</span></span> <span class=\"hljs-built_in\">String</span>(乱码变量.getBytes(<span class=\"hljs-string\">\"原编码格式\"</span>),<span class=\"hljs-string\">\"现编码格式\"</span>);</pre></div></div></div>','java乱码','乱码',4,'http://localhost:9010/picture/2019—01-31 21-45-53.jpg','2019-02-05 01-52-38',2,1,'java乱码',2,'javaSE ',8,NULL),(34,0,'<h1 style=\"background-color: rgb(245, 245, 244); border: 1px solid rgb(208, 207, 207); color: rgb(170, 118, 82); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 18px; font-variant-numeric: normal; font-variant-east-asian: normal; font-weight: 700; line-height: 27px; margin-top: 35px; padding: 5px 8px;\" id=\"nav1_1\">mysql安装</h1><span style=\"background-color: transparent; color: rgb(17, 17, 17); font-family: Verdana, Arial, Helvetica, sans-serif; font-variant-numeric: normal; font-variant-east-asian: normal;\">\n</span><p style=\"background-color: transparent; color: rgb(85, 84, 84); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 15px; font-variant-numeric: normal; font-variant-east-asian: normal; margin-bottom: 2px; margin-top: 2px;\"><a href=\"http://baike.baidu.com/subview/24816/15308361.htm\" target=\"_blank\" style=\"color: rgb(194, 143, 108);\" data-lemmaid=\"471251\">MySQL</a>是一种<a href=\"http://baike.baidu.com/view/1708.htm\" target=\"_blank\" style=\"color: rgb(194, 143, 108);\">开放源代码</a>的关系型<a href=\"http://baike.baidu.com/view/600155.htm\" target=\"_blank\" style=\"color: rgb(194, 143, 108);\">数据库管理</a>系统（RDBMS），MySQL<a href=\"http://baike.baidu.com/view/7809.htm\" target=\"_blank\" style=\"color: rgb(194, 143, 108);\">数据库系统</a>使用最常用的数据库管理语言--<a href=\"http://baike.baidu.com/view/595350.htm\" target=\"_blank\" style=\"color: rgb(194, 143, 108);\">结构化查询语言</a>（SQL）进行数据库管理。在 WEB 应用方面MySQL是最好的 RDBMS (Relational Database Management System，关系数据库管理系统) 应用软件之一。</p><span style=\"background-color: transparent; color: rgb(17, 17, 17); font-family: Verdana, Arial, Helvetica, sans-serif; font-variant-numeric: normal; font-variant-east-asian: normal;\">\n</span><p style=\"background-color: transparent; color: rgb(85, 84, 84); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 15px; font-variant-numeric: normal; font-variant-east-asian: normal; margin-bottom: 2px; margin-top: 2px;\">使用mysql必须具备一下条件</p><span style=\"background-color: transparent; color: rgb(17, 17, 17); font-family: Verdana, Arial, Helvetica, sans-serif; font-variant-numeric: normal; font-variant-east-asian: normal;\">\n</span><ul style=\"background-color: transparent; color: rgb(17, 17, 17); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 15px; font-variant-numeric: normal; font-variant-east-asian: normal; margin-bottom: 0px; margin-left: 15px;\">\n<li style=\"background-image: url(&quot;https://images2015.cnblogs.com/blog/208266/201608/208266-20160821195445230-530388031.gif&quot;); background-position: 0px 9px; background-repeat: no-repeat; color: rgb(85, 84, 84); list-style-image: none; list-style-position: outside; padding-left: 15px;\">　　a. 安装MySQL服务端</li>\n<li style=\"background-image: url(&quot;https://images2015.cnblogs.com/blog/208266/201608/208266-20160821195445230-530388031.gif&quot;); background-position: 0px 9px; background-repeat: no-repeat; color: rgb(85, 84, 84); list-style-image: none; list-style-position: outside; padding-left: 15px;\">　　b. 安装MySQL客户端</li>\n<li style=\"background-image: url(&quot;https://images2015.cnblogs.com/blog/208266/201608/208266-20160821195445230-530388031.gif&quot;); background-position: 0px 9px; background-repeat: no-repeat; color: rgb(85, 84, 84); list-style-image: none; list-style-position: outside; padding-left: 15px;\">　　b. 【客户端】连接【服务端】</li>\n<li style=\"background-image: url(&quot;https://images2015.cnblogs.com/blog/208266/201608/208266-20160821195445230-530388031.gif&quot;); background-position: 0px 9px; background-repeat: no-repeat; color: rgb(85, 84, 84); list-style-image: none; list-style-position: outside; padding-left: 15px;\">　　c. 【客户端】发送命令给【服务端MySQL】服务的接受命令并执行相应操作(增删改查等)</li>\n</ul><span style=\"background-color: transparent; color: rgb(17, 17, 17); font-family: Verdana, Arial, Helvetica, sans-serif; font-variant-numeric: normal; font-variant-east-asian: normal;\">\n</span><p style=\"background-color: transparent; color: rgb(85, 84, 84); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 15px; font-variant-numeric: normal; font-variant-east-asian: normal; margin-bottom: 2px; margin-top: 2px;\">1、下载地址：<code class=\"javascript plain\" style=\"font-size: 15px; padding: 0px;\">http:</code><code class=\"javascript comments\" style=\"font-size: 15px; padding: 0px;\">//dev.mysql.com/downloads/mysql/</code></p><span style=\"background-color: transparent; color: rgb(17, 17, 17); font-family: Verdana, Arial, Helvetica, sans-serif; font-variant-numeric: normal; font-variant-east-asian: normal;\">\n</span><p style=\"background-color: transparent; color: rgb(85, 84, 84); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 15px; font-variant-numeric: normal; font-variant-east-asian: normal; margin-bottom: 2px; margin-top: 2px;\">2、安装</p><span style=\"background-color: transparent; color: rgb(17, 17, 17); font-family: Verdana, Arial, Helvetica, sans-serif; font-variant-numeric: normal; font-variant-east-asian: normal;\">\n</span><ul style=\"background-color: transparent; color: rgb(17, 17, 17); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 15px; font-variant-numeric: normal; font-variant-east-asian: normal; margin-bottom: 0px; margin-left: 15px;\">\n<li style=\"background-image: url(&quot;https://images2015.cnblogs.com/blog/208266/201608/208266-20160821195445230-530388031.gif&quot;); background-position: 0px 9px; background-repeat: no-repeat; color: rgb(85, 84, 84); list-style-image: none; list-style-position: outside; padding-left: 15px;\">windows安装请参考：http://www.cnblogs.com/lonelywolfmoutain/p/4547115.html</li>\n<li style=\"background-image: url(&quot;https://images2015.cnblogs.com/blog/208266/201608/208266-20160821195445230-530388031.gif&quot;); background-position: 0px 9px; background-repeat: no-repeat; color: rgb(85, 84, 84); list-style-image: none; list-style-position: outside; padding-left: 15px;\">linux下安装：http://www.cnblogs.com/chenjunbiao/archive/2011/01/24/1940256.html</li>\n</ul><span style=\"background-color: transparent; color: rgb(17, 17, 17); font-family: Verdana, Arial, Helvetica, sans-serif; font-variant-numeric: normal; font-variant-east-asian: normal;\">\n</span><p style=\"background-color: transparent; color: rgb(85, 84, 84); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 15px; font-variant-numeric: normal; font-variant-east-asian: normal; margin-bottom: 2px; margin-top: 2px;\">&nbsp;注：以上两个链接有完整的安装方式，撸主也是参考他的安装的，安装完以后mysql.server start启动mysql服务</p>','MySQL安装','MySQL',3,'http://localhost:9010/picture/2019—01-31 21-45-53.jpg','2019-02-05 01-54-39',2,1,'MySQL安装',2,'MySQL',9,NULL),(37,0,'<div>二、常见操作</div><div>经过上面的下载安装，已做好了MySQL的准备，下面，我们来做一个常用的简单操作。</div><div><br></div><div>&nbsp;1.&nbsp; 对数据库的操作</div><div><br></div><div>1)&nbsp; &nbsp; 创建数据库，创建一个名为：students 的数据库：CREATE DATABASE if NOT EXISTS students;</div><div><br></div><div>2)&nbsp; &nbsp; 查看所有数据库：SHOW DATABASES;</div><div><br></div><div>3)&nbsp; &nbsp; 使用或切换数据库 Use dbname，如：切换到students数据库USE students;</div><div><br></div><div>4)&nbsp; 删除数据库DROP DATABASE IF EXISTS students;</div><div><br></div><div>5)&nbsp; 修改数据库名&nbsp;</div><div><br></div><div>&nbsp;2.&nbsp; 对表的操作</div><div><br></div><div>改模块的操作以students数据库，scores表为基础。</div><div><br></div><div>1) 创建表（scores）CREATE TABLE scores(id INT PRIMARY KEY,NAME VARCHAR(40),lesson VARCHAR(60),score INT);</div><div><br></div><div>2) 往表中插入一条数据INSERT INTO scores(id,name,lesson,score) VALUES(10,\"smaile\",\"mysql\",90);</div><div><br></div><div>3) 查询数据库中的所有表SHOW TABLES FROM students;</div><div><br></div><div>4) 查询一张表（scores）的所有字段SHOW COLUMNS FROM scores;</div><div><br></div><div>5) 查询表SELECT * FROM scores;</div><div><br></div><div>6) 删除表DROP TABLE IF EXISTS scores;&nbsp;</div><div><br></div><div>&nbsp;3.&nbsp; 修改表结构</div><div><br></div><div>1) 修改表中的字段的名字CHANGE（将NAME改为name）：ALTER TABLE scores CHANGE NAME name VARCHAR(32);</div><div><br></div><div>2) 修改表中的字段类型：MODIFYALTER TABLE scores MODIFY NAME int;</div><div><br></div><div>3) 给表添加一个列ADD：ALTER TABLE scores ADD note VARCHAR(255);</div><div><br></div><div>4) 删除表中的一个列DROP：ALTER TABLE scores DROP note</div>','MySQL常见操作','MySQL',2,'/http://localhost:9010picture/2019—01-31 21-46-03.jpg','2019-02-05 02-15-03',2,1,'MySQL常见操作',2,'MySQL',9,NULL),(39,0,'<p>创建查询环境</p><p>　　　　　　　　　CREATE TABLE fruits(</p><p>　　　　　　　　　　　f_id CHAR(10) NOT NULL,</p><p>　　　　　　　　　　　s_id INT NOT NULL,</p><p>　　　　　　　　　　　f_name char(255) NOT NULL,</p><p>　　　　　　　　　　　f_price DECIMAL(8,2) NOT NULL,</p><p>　　　　　　　　　　　PRIMARY KEY(f_id)</p><p>　　　　　　　　　);</p><p>　　　　　　　　　解释：</p><p>　　　　　　　　　　　　f_id：主键 使用的是CHAR类型的字符来代表主键</p><p>　　　　　　　　　　　&nbsp; &nbsp;s_id：这个其实是批发商的编号，也就是代表该水果是从哪个批发商那里过来的，写这个字段的目的是为了方便后面扩增表。</p><p>　　　　　　　　　　　　f_name：水果的名字</p><p>　　　　　　　　　　　　f_price：水果的价格，使用的是DECIMAL这个数据类型，如果不清楚这个类型去查看一下上面一篇讲解数据类型的文章。</p><p>　　　　　　　添加数据。</p><p>　　　　　　　　　INSERT INTO fruits(f_id,s_id,f_name,f_price) VALUES</p><p>　　　　　　　　　　　　(\'a1\' , 101 , \'apple\' , 5.2),</p><p>　　　　　　　　　　　　(\'b1\' , 101 , \'blackberry\' , 10.2),</p><p>　　　　　　　　　　　　(\'bs1\' , 102 , \'orange\' , 11.2),</p><p>　　　　　　　　　　　　(\'bs2\' , 105 , \'melon\' , 8.2),</p><p>　　　　　　　　　　　　(\'t1\' , 102 , \'banana\' , 10.3),</p><p>　　　　　　　　　　　　(\'t2\' , 102 , \'grape\' , 5.3),</p><p>　　　　　　　　　　　　(\'o2\' , 103 , \'coconut\' , 9.2),</p><p>　　　　　　　　　　　　(\'c0\' , 101 , \'cherry\' , 3.2),</p><p>　　　　　　　　　　　　(\'a2\' , 103 , \'apricot\' , 2.2),</p><p>　　　　　　　　　　　　(\'l2\' , 104 , \'lemon\' , 6.4),</p><p>　　　　　　　　　　　　(\'b2\' , 104 , \'berry\' , 7.6),</p><p>　　　　　　　　　　　　(\'m1\' , 106, \'mango\' , 15.6),</p><p>　　　　　　　　　　　　(\'m2\' , 105 , \'xbabay\' , 2.6),</p><p>　　　　　　　　　　　　(\'t4\' , 107, \'xbababa\' , 3.6),</p><p>　　　　　　　　　　　　(\'m3\' , 105 , \'xxtt\' , 11.6),</p><p>　　　　　　　　　　　　(\'b5\' , 107, \'xxxx\' , 3.6 );</p><p>　　　　　　blackberry：黑莓　　melon：甜瓜　　grape：葡萄　　coconut：椰子　　cherry：樱桃　　apricot：杏子　　berry：浆果　　mango：芒果　　后面几个xbabay都是为了测试所编写的，没有实际意义。</p><p>&nbsp;　　　　　　注意：在复制我的代码到cmd窗口时，应注意语句之间不能有空格，不然会报错，我这里是为了使你们观看更清楚，所以每行前面度加有空格，　　　　</p>','单表查询','MySQL；单表查询',1,'http://localhost:9010/picture/2019—01-31 21-46-43.jpg','2019-02-05 02-21-04',2,1,'MySQL单表查询（一）',2,'MySQL',9,NULL),(40,0,'<p>1.1、查询所有字段</p><p>　　　　　　　　　　SELECT * FROM fruits;</p><p>&nbsp;　　　　　　　　　　　　　　　　　　　　</p><p>　　　　　　　　　　　　解释：* 代表所有字段，也就是从表中将所有字段下面的记录度查询出来</p><p>　　　　　　1.2、查询指定字段</p><p>　　　　　　　　　　　　查询f_name 和 f_price 字段的记录</p><p>　　　　　　　　　　　　SELECT f_name, f_price FROM fruits;</p><p>　　　　　　　　　　　　　　　　　　　　</p><p>&nbsp;</p><p>　　　　　　1.3、查询指定记录</p><p>　　　　　　　　　　　　指定记录：也就是按条件进行查询，将满足一定条件的记录给查询出来，使用WHERE关键字</p><p>　　　　　　　　　　　　SELECT * FROM fruits WHERE f_name = \'apple\';　　//将名为apple的记录的所有信息度查询出来</p><p>　　　　　　　　　　　　　　　　　　　　</p><p>&nbsp;</p><p>　　　　　　　　　　　　SELECT * FROM fruits WHERE f_price &gt; 15；　　　　//将价格大于15的记录的所有字段　　查询出来</p><p>　　　　　　　　　　　　　　　　　　　　</p><p>&nbsp;</p><p>　　　　　　1.4、带IN关键字的查询</p><p>　　　　　　　　　　　　IN关键字：IN(xx，yy，...) 满足条件范围内的一个值即为匹配项&nbsp;</p><p>　　　　　　　　　　　　SELECT * FROM fruits WHERE f_name IN(\'apple\',\'orange\');</p><p>　　　　　　　　　　　　　　　　　　　　</p><p>&nbsp;</p><p>　　　　　　　　　　　　SELECT * FROM fruits WHERE s_id IN(101, 105);&nbsp; //s_id 为101 或者 105 的记录</p><p>　　　　　　　　　　　　　　　　　　　　</p><p>&nbsp;</p><p>　　　　　　　　　　　　SELECT * FROM fruits WHERE s_id NOT IN(101,105); //s_id 不为101或者105的记录</p><p>　　　　　　　　　　　　　　　　　　　　</p><p>　　　　　　　　　　　　</p><p>　　　　　　1.5、带BETWEEN AND 的范围查询</p><p>　　　　　　　　　　　　BETWEEN ... AND ... : 在...到...范围内的值即为匹配项，</p><p>　　　　　　　　　　　　SELECT * FROM fruits WHERE f_price BETWEEN 5 AND 15;　　//f_price 在5到15之间，包括5和15。</p><p>　　　　　　　　　　　　　　　　　　　　</p><p>&nbsp;</p><p>　　　　　　　　　　　　SELECT * FROM fruits WHERE f_price NOT BETWEEN 5 AND 15;　　//f_price 不在5到15之间。</p><p>　　　　　　　　　　　　　　　　　　　　</p><p>　　　　</p><p>　　　　　　1.6、带LIKE的字符匹配查询</p><p>&nbsp;　　　　　　　　　　　　　LIKE: 相当于模糊查询，和LIKE一起使用的通配符有&nbsp; \"%\"、\"_\"&nbsp;&nbsp;</p><p>　　　　　　　　　　　　　　　　　\"%\"：作用是能匹配任意长度的字符。</p><p>　　　　　　　　　　　　　　　　　\"_\"：只能匹配任意一个字符</p><p>　　　　　　　　　　　　　SELECT * FROM fruits WHERE f_name LIKE \'b%\';　　//f_name以b字母开头的所有记录</p><p>　　　　　　　　　　　　　　　　　　　　</p><p>　　　　　　　　　　　　　SELECT * FROM fruits WHERE f_name LIKE \'b%y\';　　//f_name以b字母开头，y字母结尾的所有记录</p><p>　　　　　　　　　　　　　　　　　　　　</p><p>　　　　　　　　　　　　　SELECT * FROM fruits WHERE f_name LIKE \'____y\'; 　　//此处有四个_，说明要查询以y字母结尾并且y之前只有四个字符的记录</p><p>　　　　　　　　　　　　　　　　　　　　</p><p>　　　　　　　　　　　　　总结：\'%\'和\'_\'可以在任意位置使用，只需要记住%能够表示任意个字符，_只能表示一个任意字符</p><p>　　　　　　　　　　　　　　　　　　　　</p><p>　　　　　　1.7、查询空值</p><p>　　　　　　　　　　　　　空值不是指为空字符串\"\"或者0，一般表示数据未知或者在以后在添加数据，也就是在添加数据时，其字段上默认为NULL，也就是说，如果该字段上不插入任何值，就为NULL。此时就可以查询出来。&nbsp;</p><p>　　　　　　　　　　　　　SELECT * FROM 表名 WHERE 字段名 IS NULL;　　//查询字段名是NULL的记录</p><p>　　　　　　　　　　　　　SELECT * FROM 表名 WHERE 字段名 IS NOT NULL;　　//查询字段名不是NULL的记录</p><p>　　　　　　　　　　　　　这里由于没有合适的数据，就不自己在创建表，添加数据，然后来测试这条语句了，很简单，看一下就应该懂了</p><p>&nbsp;</p><p>　　　　　　1.8、带AND的多条件查询</p><p>　　　　　　　　　　　　　AND: 相当于\"逻辑与\"，也就是说要同时满足条件才算匹配&nbsp;</p><p>　　　　　　　　　　　　　SELECT * FROM fruits WHERE s_id = 101 AND f_price &gt; 5;　　//同时满足s_id = 101、f_price &gt;5 这两个条件才算匹配。</p>','单表查询','MySQL；单表查询',0,'http://localhost:9010/picture/2019—01-31 21-46-43.jpg','2019-02-05 02-22-26',2,1,'MySQL单表查询（二）',2,'MySQL',9,NULL),(41,0,'<div>1.9、带OR的多条件查询</div><div>　　　　　　　　　　　　　OR: 相当于\"逻辑或\"，也就是说只要满足其中一个条件，就算匹配上了，跟IN关键字效果差不多&nbsp;</div><div>　　　　　　　　　　　　　SELECT * FROM fruits WHERE s_id = 101 OR f_price &gt; 10;　　//s_id =101 或者 f_price &gt;10 ，只要符合其中一个条件，就算匹配</div><div>　　　　　　　　　　　　　　　　　　　　　　</div><div>　　　　　　　　　　　　　　可以看到，查询出来的记录，f_price有低于10的，那么其肯定s_id=101，s_id不等于101的，其f_price肯定大于10，这就说明了OR的效果。只要满足其中一个条件，就算匹配。</div><div>&nbsp;&nbsp;</div><div>　　　　　　1.10、关键字DISTINCT(查询结果不重复)</div><div>　　　　　　　　　　　　　　SELECT s_id FROM fruits;　　//查询所有的s_id，会出现很多重复的值。</div><div>　　　　　　　　　　　　　　　　　　　　　　　　　　</div><div>　　　　　　　　　　　　　　使用DISTINCT就能消除重复的值</div><div>　　　　　　　　　　　　　　SELECT DISTINCT s_id FROM fruits;</div><div>　　　　　　　　　　　　　　　　　　　　　　　　　　</div><div>　　　　　　　　　　　　　　将重复的值删除后，就只留下7条记录了。</div><div>　　　　　　　　　　　　　　　　&nbsp;</div><div>　　　　　　1.11、对查询结果排序(ORDER BY)</div><div>　　　　　　　　　　　　　　看上面输出的值没顺序，可以给他们进行排序。使用关键字 ORDER BY，有两个值供选择 DESC 降序 、 ASC 升序(默认值)&nbsp;</div><div>　　　　　　　　　　　　　　SELECT DISTINCT s_id FROM fruits ORDER BY s_id;　　　　//默认就是升序，</div><div>　　　　　　　　　　　　　　　　　　　　　　　　　　</div><div>　　　　　　　　　　　　　　SELECT DISTINCT s_id FROM fruits ORDER BY s_id DESC;　　//使用降序，也就是从高到底排列</div><div>　　　　　　　　　　　　　　　　　　　　　　　　　</div><div>　　　　　　1.12、分组查询(GROUP BY)</div><div>　　　　　　　　　　　　　　分组查询很多人不知道什么意思，一开始我也是很蒙圈的，所以没关系，一起来看看。</div><div>　　　　　　　　　　　　　　分组查询就是将相同的东西分到一个组里面去，现实生活中举个例子，厕所分男女，这也是一个分组的应用，在还没有分男女厕所前，大家度共用厕所，后面通过分男女性别，男的跟男的分为一组，女的和女的分为一组，就这样分为了男女厕所了。这就是分组的意思， 在上面对s_id进行查询的时候，发现很多重复的值，我们也就可以对它进行分组，将相同的值分为一组，</div><div>　　　　　　　　　　　　　　SELECT s_id FROM fruits GROUP BY s_id;　　//将s_id进行分组，有实际意义，按批发商进行分组，从101批发商这里拿的水果度会放在101这个组中</div><div>　　　　　　　　　　　　　　　　　　　　　　　　　</div><div>　　　　　　　　　　　　　　解释：将s_id分组后，就没有重复的值了，因为重复的度被分到一个组中去了，现在在来看看每个组中有多少个值</div><div>　　　　　　　　　　　　　　SELECT s_id, COUNT(f_name), GROUP_CONCAT(f_name) FROM fruits GROUP BY s_id;</div><div>　　　　　　　　　　　　　　　　　　　　　　　　　　</div><div>　　　　　　　　　　　　　　解释：</div><div>　　　　　　　　　　　　　　　　COUNT():这个是下面要讲解到的一个函数，作用就是计算有多少条记录，　</div><div>　　　　　　　　　　　　　　　　GROUP_CONCAT(): 将分组中的各个字段的值显示出来　</div><div>　　　　　　　　　　　　　&nbsp; SELECT s_id, COUNT(f_name), GROUP_CONCAT(f_name), GROUP_CONCAT(f_price) FROM fruits GROUP BY s_id; 　　　　　　　　</div><div>　　　　　　　　　　　　　　　　　　　　　　　　　　</div><div>&nbsp;</div><div>　　　　　　　　　　　　　　分组之后还可以进行条件过滤，将不想要的分组丢弃，使用关键字 HAVING</div><div>　　　　　　　　　　　　　　SELECT s_id,COUNT(f_name),GROUP_CONCAT(f_name) FROM fruits GROUP BY s_id HAVING COUNT(f_name) &gt; 1;//他能够过s_id分组，然后过滤出水果种类大于1的分组信息。</div><div>　　　　　　　　　　　　　　　　　　　　　　　　　　&nbsp;</div><div>　　　　　　　　　　　　　　总结：</div><div>　　　　　　　　　　　　　　　　　知道GROUP BY的意义，并且会使用HAVING对分组进行过滤， HAVING和WHERE都是进行条件过滤的，区别就在于 WHERE 是在分组之前进行过滤，而HAVING是在分组之后进行条件过滤。</div><div>　　　　　　1.13、使用LIMIT限制查询结果的数量　　</div><div>　　　　　　　　　　　　　　LIMIT[位置偏移量] 行数&nbsp; 通过LIMIT可以选择数据库表中的任意行数，也就是不用从第一条记录开始遍历，可以直接拿到 第5条到第10条的记录，也可以直接拿到第12到第15条的记录。 具体看下面例子</div><div>　　　　　　　　　　　　　　SELECT * FROM fruits LIMIT 4;　　//没有写位置偏移量，默认就是0，也就是从第一条开始，往后取4条数据，也就是取了第一条数据到第4条的数据。&nbsp;</div><div>　　　　　　　　　　　　　　　　　　　　　　　　　</div><div>　　　　　　　　　　　　　　SELECT * FROM fruits LIMIT 4,3;　　//从第5条数据开始，往后取3条数据，也就是从第5条到第8条</div><div>　　　　　　　　　　　　　　　　　　　　　　　　　</div><div>　　　　　　　　　　　　　　注意:LIMIT的第一个参数不写默认就是0，也就是说，第一条记录的索引是0，从0开始的，第二个参数的意思是取多少行的记录，需要这两个才能确定一个取记录的范围</div><div>&nbsp;</div><div>　　　集合函数查询</div><div>&nbsp;</div><div>　　　　　　1.14、COUNT()函数</div><div>　　　　　　　　　　　　　　这个函数在上面其实用过，作用是统计数据表中包含的记录行的总数，或者根据查询结果返回列中包含的数据行数，&nbsp;</div><div>　　　　　　　　　　　　　　　　COUNT(*):计算表中的总的行数，不管某列有数值或者为空值，因为*就是代表查询表中所有的数据行</div><div>　　　　　　　　　　　　　　　　COUNT(字段名):计算该字段名下总的行数，计算时会忽略空值的行，也就是NULL值的行。</div><div>　　　　　　　　　　　　　　SELECT COUNT(*) FROM fruits;</div><div>　　　　　　　　　　　　　　　　　　　　　　　　　　</div><div>　　　　　　　　　　　　　　SELECT COUNT(f_name) FROM fruits;　　//查询fruits表中f_name字段名下有多少个行数，</div><div>　　　　　　　　　　　　　　　　　　　　　　　　　　</div><div>　　　　　　　　　　　　　　　　　　　　没有空值，所以计算出来的行数和总的记录行数是一样的。</div><div>&nbsp;</div><div>　　　　　　1.15、SUM()函数</div><div>　　　　　　　　　　　　　&nbsp; SUM()是一个求总和的函数，返回指定列值的总和</div><div>　　　　　　　　　　　　　　SELECT SUM(f_price) FROM fruits;　　//这个没有实际的意义，只是测试SUM()函数有求总和的能力</div><div>　　　　　　　　　　　　　　　　　　　　　　　　　</div><div>　　　　　　　　　　　　　　　　　　　如果有人觉得这个测试的不准，可以手动去加一下所有的f_price。然后来进行对比，反正我是信了。</div><div>　　　　　　1.16、AVG()函数</div><div>&nbsp;　　　　　　　　　　　　　AVG()函数通过计算返回的行数和每一行数据的和，求的指定列数据的平均值(列数据指的就是字段名下的数据，不要搞不清楚列和行，搞不清就对着一张表搞清楚哪个是列哪个是行)，通俗点讲，就是将计算得来的总之除以总的记录数，得出一个平均值，</div><div>　　　　　　　　　　　　　 SELECT AVG(f_price) FROM fruits;　　</div><div>　　　　　　　　　　　　　　　　　　　　　　　　　</div><div>　　　　　　　　　　　　　　　　　　　　就相当于　　116/16 = 7.25</div><div>　　　　　　1.17、MAX()函数</div><div>&nbsp;　　　　　　　　　　　　　　MAX()返回指定列中的最大值</div><div>　　　　　　　　　　　　　　 SELECT MAX(f_price) FROM fruits;</div><div>　　　　　　　　　　　　　　　　　　　　　　　　　　</div><div>　　　　　　1.18、MIN()函数　　　　　　　　　　　　　</div><div>&nbsp;　　　　　　　　　　　　　MIN()返回查询列中的最小值</div><div>　　　　　　　　　　　　　 SELECT MIN(f_price) FROM fruits;</div>','单表查询','MySQL；单表查询',0,'http://localhost:9010/picture/2019—01-31 21-46-43.jpg','2019-02-05 02-23-02',2,1,'MySQL单表查询（三）',2,'MySQL',9,NULL),(42,0,'<div>小知识</div><div>　　　　　　为表取别名</div><div>&nbsp;　　　　　　　　　　因为是对两张表进行查询了，那么每次写表名的话就有点麻烦，所以用一个简单别名来代表表名</div><div>　　　　　　　　　　 格式：表名 AS 别名</div><div>　　　　　　　　　　 在下面的例子中会用的到，到时候不要不认识</div><div>　　　　　　为字段取别名</div><div>&nbsp;　　　　　　　　　　给字段名取别名的原因是有些字段名是为了显示更加清楚，比如</div><div>　　　　　　　　　　　　　　　　SELECT f_price AS \'价格\' FROM fruits;</div><div>　　　　　　　　　　　　　　　　　　　　　　　　　　</div><div>　　　　　　语句执行顺序问题</div><div>　　　　　　　　　　　　一、sql执行顺序 、</div><div>　　　　　　　　　　　　　　(1)from 　　</div><div>　　　　　　　　　　　　　　(2) on&nbsp;</div><div>　　　　　　　　　　　　　　(3) join&nbsp;</div><div>　　　　　　　　　　　　　　(4) where&nbsp;</div><div>　　　　　　　　　　　　　　(5)group by&nbsp;</div><div>　　　　　　　　　　　　　　(6) avg,sum....&nbsp;</div><div>　　　　　　　　　　　　　　(7)having&nbsp;</div><div>　　　　　　　　　　　　　　(8) select&nbsp;</div><div>　　　　　　　　　　　　　　(9) distinct&nbsp;</div><div>　　　　　　　　　　　　　　(10) order by&nbsp;</div><div>　　　　　　　　　　也就是说，我们每次执行的SQL语句，都是从FROM开始的。</div><div>　　　基于两张表　</div><div>&nbsp;　　　　　搭建查询环境，前面已经有一张表了，现在在增加一张suppliers(供应商)表和前面哪个fruits表创建练习，也就是说 让fruits中s_id字段值指向suppliers的主键值，创建一个外键约束关系。</div><div>　　　　　　　　CREATE TABLE suppliers　　</div><div>　　　　　　　　(</div><div>　　　　　　　　　　s_id INT NOT NULL,</div><div>　　　　　　　　　　s_name CHAR(50) NOT NULL,</div><div>　　　　　　　　　　s_city CHAR(50) NULL,</div><div>　　　　　　　　　　s_zip CHAR(10) NULL,</div><div>　　　　　　　　　　s_call CHAR(50) NOT NULL,</div><div>　　　　　　　　　　PRIMARY KEY(s_id)</div><div>　　　　　　　　);</div><div>　　　　　　　　其实这里并没有达到真正的外键约束关系，只是模拟，让fruits中的s_id中的值 能匹配到 suppliers 中的主键值，通过手动添加这种数据，来达到这种关系，反正是死数据，也不在添加别的数据，就不用建立外键约束关系了，这里要搞清楚</div><div>　　　　　　　　INSERT INTO suppliers(s_id,s_name,s_city,s_zip,s_call)</div><div>　　　　　　　　VALUES</div><div>　　　　　　　　(101,\'Supplies A\',\'Tianjin\',\'400000\',\'18075\'),</div><div>　　　　　　　　(102,\'Supplies B\',\'Chongqing\',\'400000\',\'44333\'),</div><div>　　　　　　　　(103,\'Supplies C\',\'Shanghai\',\'400000\',\'90046\'),</div><div>　　　　　　　　(104,\'Supplies D\',\'Zhongshan\',\'400000\',\'11111\'),</div><div>　　　　　　　　(105,\'Supplies E\',\'Taiyuang\',\'400000\',\'22222\'),</div><div>　　　　　　　　(106,\'Supplies F\',\'Beijing\',\'400000\',\'45678\'),</div><div>　　　　　　　　(107,\'Supplies G\',\'Zhengzhou\',\'400000\',\'33332\');</div>','多表查询','MySQL；多表查询',0,'http://localhost:9010/picture/2019—01-31 21-46-43.jpg','2019-02-05 02-37-00',2,1,'MySQL多表查询（一）',2,'MySQL',9,NULL),(43,0,'<div>　1、普通双表连接查询</div><div>&nbsp;　　　　　　　　　　问题：查询水果的批发商编号，批发商名字，水果名称，水果价格</div><div>　　　　　　　　　　　　　分析：看下要求，就知道要查询两张表，如果需要查询两张表，那么两张表的关系必定是外键关系，或者类似于外键关系(类似于也就是说两张表并没有真正加外键约束，但是其特点和外键是一样的，就像上面我们手动创建的两张表一样，虽然没有设置外键关联关系，但是其特性跟外键关系是一样的。)</div><div>　　　　　　　　　　 SELECT s.s_id,s.s_name,f.f_name,f.f_price FROM fruits AS f, suppliers AS s WHERE f.s_id = s.s_id;</div><div>　　　　　　　　　　　　　　　　　　　　　　</div><div>　　　　　　　　　　　　　　解释：这里使用了表别名，并且这里是连接两张表的关系是在于 fruits中的s_id 等于 suppliers中的s_id。 这个大家度能理解把，也就是水果中记录了批发商的编号，通过该编号就能在suppliers表中找到对应的批发商的详细信息，就这样，两张表就联系起来了。&nbsp;</div><div>　　　　　　　　　　　　　　注意：第一个执行的是FROM，所以上面为表取别名，在语句的任何地方的可以使用。</div><div>　　　　　　2、内连接查询</div><div>&nbsp;　　　　　　　　　　　　　　知道了上面两张表基本的连接查询后，内连接查询就很简单了，因为内连接跟上面的作用是一样的，唯一的区别就是语法的不一样</div><div>　　　　　　　　　　　　　　 格式：表名 INNER JOIN 表名 ON 连接条件</div><div>　　　　　　　　　　　　　　 问题：查询水果的批发商编号，批发商名字，水果名称，水果价格</div><div>　　　　　　　　　　　　　　　　 SELECT s.s_id,s.s_name,f.f_name,f.f_price&nbsp;</div><div>　　　　　　　　　　　　　　　　 FROM fruits AS f INNER JOIN suppliers AS s&nbsp;</div><div>　　　　　　　　　　　　　　　　 ON f.s_id = s.s_id;</div><div>　　　　　　　　　　　　　　不知道这样写sql语句会不会让你们看的更清楚</div><div>　　　　　　　　　　　　　　　　　　　　</div><div>　　　　　　　　　　　　　　</div><div>　　　　　　　　　　　　还需要知道一个特殊一点的东西，那就是自连接查询，什么是自连接查询？就是涉及到的两张表都是同一张表。</div><div>　　　　　　　　　　　　问题：查询供应f_id=\'a1\'的水果供应商提供的其他水果种类？</div><div>　　　　　　　　　　　　　　SELECT f2.f_id,f2.f_name</div><div>　　　　　　　　　　　　　　FROM fruits AS f1 INNER JOIN fruits AS f2</div><div>　　　　　　　　　　　　　　ON f1.s_id = f2.s_id AND f1.f_id = \'a1\';</div><div>　　　　　　　　　　　　　　　　　　　　　　</div><div>　　　　　　　　　　　　　　解释：把fruits表分开看成是两张完全一样的表，在f1表中找到f_id=\'a1\'的s_id，然后到f2这张表中去查找和该s_id相等的记录，也就查询出来了问题所需要的结果。还有另一种方法，不用内连接查询，通过子查询也可以做到，下面会讲解，这里先给出答案，到时可以回过头来看看这个题。</div><div>　　　　　　　　　　　　　　SELECT f_id,f_name</div><div>　　　　　　　　　　　　　　FROM fruits</div><div>　　　　　　　　　　　　　　WHERE s_id = (SELECT s_id FROM fruits WHERE f_id=\'a1\');</div><div>　　　　　　　　　　　　　　　　　　　　　　</div><div>　　　　　　　　　　　　　　效果和内连接是一样的，其实原理度是一样的，还是借助的两张表，只是这个更容易让人理解，可以通过这个来去理解上面那个自连接查询。</div><div>&nbsp;</div><div>　　　　　　3、外连接查询</div><div>&nbsp;　　　　　　　　　　　　　　内连接是将符合查询条件(符合连接条件)的行返回，也就是相关联的行就返回。</div><div>　　　　　　　　　　　　　　 外连接除了返回相关联的行之外，将没有关联的行也会显示出来。</div><div>　　　　　　　　　　　　　　 为什么需要将不没关联的行也显示出来呢？这就要根据不同的业务需求了，就比如，order和customers，顾客可以有订单也可以没订单，现在需要知道所有顾客的下单情况，而我们不能够只查询出有订单的用户，而把没订单的用户丢在一边不显示，这个就跟我们的业务需求不相符了，有人说，既然知道了有订单的顾客，通过单表查询出来不包含这些有订单顾客，不就能达到我们的要求吗，这样是可以，但是很麻烦，如何能够将其一起显示并且不那么麻烦呢？为了解决这个问题，就有了外连接查询这个东西了。</div><div>　　　　　　　　　3.1、左外连接查询</div><div>　　　　　　　　　　　　　　 格式： 表名 LEFT JOIN 表名 ON 条件； 返回包括左表中的所有记录和右表中连接字段相等的记录，通俗点讲，就是除了显示相关联的行，还会将左表中的所有记录行度显示出来。用例子来展示一下所说效果把。</div><div>　　　　　　　　　　　　　　 由于上面我们所用到的fruits和suppliers中的记录都是设计好的，并没有哪个供应商没有提供水果，现在为了体现左外连接的效果，在suppliers中增加两条记录，fruits中并没有对应这两条记录得水果信息，</div><div>　　　　　　　　　　　　　　 INSERT INTO suppliers VALUES(108,\'suppliers T\',\'Jiangxi\',\'33333\',\'11111\');</div><div>　　　　　　　　　　　　　　 INSERT INTO suppliers VALUES(109,\'suppliers Y\',\'Jiangxi\',\'22222\',\'44444\');&nbsp;</div><div>　　　　　　　　　　　　　　　　　　　　　　　　　　　　</div><div>　　　　　　　　　　　　　　SELECT s.s_id,s.s_name,f.f_id,f.f_name</div><div>　　　　　　　　　　　　　　FROM suppliers AS s LEFT JOIN fruits AS f</div><div>　　　　　　　　　　　　　　ON s.s_id = f.s_id;</div><div>　　　　　　　　　　　　　　　　　　　　　　　　　　　　</div><div>　　　　　　　　　　　　　　　　　　解释：</div><div>　　　　　　　　　　　　　　　　　　　　 suppliers表是在LEFT JOIN的左边，所以将其中所有记录度显示出来了，有关联项的，也有没有关联项的。这就是左外连接的意思，将左边的表所有记录都显示出来(前提是按照我们所需要的字段，也就是SELECT 后面所选择的字段)。如果将suppliers表放LEFT JOIN的右边，那么就不会在显示108和109这两条记录了。来看看</div><div>　　　　　　　　　　　　　　SELECT s.s_id,s.s_name,f.f_id,f.f_name</div><div>　　　　　　　　　　　　　　FROM&nbsp; fruits AS f LEFT JOIN suppliers AS s</div><div>　　　　　　　　　　　　　　ON s.s_id = f.s_id;</div><div>　　　　　　　　　　　　　　　　　　　　　　　　　　　　</div><div>　　　　　　　　　　　　　　　　</div><div>　　　　　　　　　3.2、右外连接查询</div><div>　　　　　　　　　　　　　　 格式： 表名 RIGHT JOIN 表名 ON 条件&nbsp; 返回包括右表中的所有记录和右表中连接字段相等的记录</div><div>　　　　　　　　　　　　　　 其实跟左外连接差不多，就是将右边的表给全部显示出来</div><div>　　　　　　　　　　　　　　　　SELECT s.s_id,s.s_name,f.f_id,f.f_name</div><div>　　　　　　　　　　　　　　　　FROM&nbsp; fruits AS f RIGHT JOIN suppliers AS s</div><div>　　　　　　　　　　　　　　　　ON s.s_id = f.s_id;　　　　　　　　　　　　　　//这条语句出来的结果是跟上面左外连接一样，就是调换了一下位置，其实效果还是一样的。</div><div>　　　　　　　　　　　　　　　　　　　　　　　　　　　　</div><div>　　　　　　　　　　　　　　　　　　　　　　　　　 　　</div><div>　　　　　　　　　　　　　　注意：</div><div>　　　　　　　　　　　　　　　　LEFT JOIN 和 RIGHT JOIN这只是一种写法，其中还有另一种写法&nbsp; LEFT OUTER JOIN 和 RIGHT OUTER JOIN .</div><div>　　　　　　　　　　　　　　　　一般写这种复杂查询的时候，写sql语句的顺序应该是先从FROM　　</div>','多表查询','MySQL；多表查询',0,'http://localhost:9010/picture/2019—01-31 21-46-43.jpg','2019-02-05 02-38-23',2,1,'MySQL多表查询（二）',2,'MySQL',9,NULL),(46,0,'<div>2.4、复合条件连接查询</div><div>&nbsp;　　　　　　　　　　　　　　在连接查询(内连接、外连接)的过程中，通过添加过滤条件，限制查询的结果，使查询的结果更加准确，通俗点讲，就是将连接查询时的条件更加细化。</div><div>　　　　　　　　　　　　　　 问题一：在fruits和suppliers表中使用INNER JOIN语法查询suppliers表中s_id为107的供应商的供货信息？</div><div>　　　　　　　　　　　　　　　　　　SELECT s.s_id,s.s_name,f.f_id,f.f_name</div><div>　　　　　　　　　　　　　　　　　　FROM suppliers AS s INNER JOIN fruits AS f&nbsp;</div><div>　　　　　　　　　　　　　　　　　　ON s.s_id = f.s_id AND s.s_id = 107;</div><div>　　　　　　　　　　　　　　　　　　　　　　　　　　　　</div><div>　　　　　　　　　　　　　　问题二：在fruits表和suppliers表之间，使用INNER JOIN语法进行内连接查询，并对查询结果进行排序</div><div>　　　　　　　　　　　　　　　　　　SELECT s.s_id,s.s_name,f.f_id,f.f_name</div><div>　　　　　　　　　　　　　　　　　　FROM suppliers AS s INNER JOIN fruits AS f</div><div>　　　　　　　　　　　　　　　　　　ON s.s_id = f.s_id&nbsp;</div><div>　　　　　　　　　　　　　　　　　　ORDER BY f.s_id;　　　　　　　　//对f.s_id进行升序。默认的是ASC，所以不用写。</div><div>　　　　　　　　　　　　　　　　　　　　　　　　　　　　</div><div>　　　　　　　　　　　　　　　　　　　　　　　　对f.s_id进行排序其实也就是对s.s_id进行排序，效果是一样的，因为条件就是f.s_id=s.s_id。</div><div>　　　子查询</div><div>&nbsp;　　　　　　　　子查询，将查询一张表得到的结果来充当另一个查询的条件，这样嵌套的查询就称为子查询</div><div>　　　　　　2.5、带ANY、SOME关键字的子查询　　　　　　　　　　　　　　</div><div>　　　　　　　　　　　搭建环境</div><div>&nbsp;</div><div>　　　　　　　　　　　　　　 CREATE TABLE tb11 (num1 INT NOT NULL);</div><div>　　　　　　　　　　　　　　 CREATE TABLE tb12 (num2 INT NOT NULL);</div><div>　　　　　　　　　　　　　　 INSERT INTO tb11 VALUES(1),(5),(13),(27);</div><div>　　　　　　　　　　　　　　 INSERT INTO tb12 VALUES(6),(14),(11),(20);</div><div>　　　　　　　　　　　ANY关键字接在一个比较操作符的后面，表示若与子查询返回的任何值比较为TRUE，则返回TRUE，通俗点讲，只要满足任意一个条件，就返回TRUE。</div><div>　　　　　　　　　　　　　&nbsp; &nbsp; SELECT num1 FROM tb11 WHERE num1 &gt; ANY(SELECT num2 FROM tb12);//这里就是将在tb12表中查询的结果放在前一个查询语句中充当条件参数。只要num1大于其结果中的任意一个数，那么就算匹配。</div><div>　　　　　　　　　　　　　　　　　　　　　　　　　　　&nbsp;</div><div>&nbsp;</div><div>　　　　　　　　　　　　SOME关键字和ANY关键字的用法一样，作用也相同，这里不做多讲解了。</div><div>&nbsp;</div><div>&nbsp;</div><div>　　　　　　2.6、带ALL关键字的子查询</div><div>&nbsp;　　　　　　　　　　　　使用ALL时表示需要同时满足所有条件。</div><div>　　　　　　　　　　　　　　　　SELECT num1 FROM tb11 WHERE num1 &gt; ALL(SELECT num2 FROM tb12);　　//num1需要大于所有的查询结果才算匹配</div><div>　　　　　　　　　　　　　　　　　　　　　　　　　　　　</div><div>　　　　　　2.7、带EXISTS关键字的子查询</div><div>　　　　　　　　　　　　EXISTS关键字后面的参数是任意一个子查询，如果子查询有返回记录行，则为TRUE，外层查询语句将会进行查询，如果子查询没有返回任何记录行，则为FALSE，外层查询语句将不会进行查询。&nbsp;</div><div>　　　　　　　　　　　　　　　　SLEECT * FROM tb11 WHERE EXISTS(SELECT * FROM tb12 WHERE num2 = 3);　　//查询tb12中有没有num2=3的记录，有的话则会将tb11的所有记录查询出来，没有的话，不做查询&nbsp;</div><div>　　　　　　　　　　　　　　　　　　　　　　　　　　　　</div><div>　　　　　　2.8、带IN关键字的子查询</div><div>　　　　　　　　　　　　 这个IN关键字的作用跟上面单表查询的IN是一样的，不过这里IN中的参数放的是一个子查询语句。</div><div>　　　　　　　　　　　　　　　　SELECT s_id,f_id,f_name</div><div>　　　　　　　　　　　　　　　　FROM fruits</div><div>　　　　　　　　　　　　　　　　WHERE s_id IN(SELECT s_id FROM suppliers WHERE s_id = 107);</div><div>　　　　　　　　　　　　　　　　　　　　　　　　　　　　</div><div>&nbsp;</div><div>　　　　　　2.9、带比较运算符的子查询</div><div>&nbsp;　　　　　　　　　　　　　除了使用关键字ALL、ANY、SOME等之外，还可以使用普通的比较运算符。来进行比较。比如我们上面讲解内连接查询的时候，就用过子查询语句，并且还是用的=这个比较运算符，这里就不做多解释了，可以往上面看一下　</div><div>　　　　</div><div>&nbsp;</div><div>　　　合并结果查询&nbsp;</div><div>　　　　　　　　利用UNION关键字，可以将查询出的结果合并到一张结果集中，也就是通过UNION关键字将多条SELECT语句连接起来，注意，合并结果集，只是增加了表中的记录，并不是将表中的字段增加，仅仅是将记录行合并到一起。其显示的字段应该是相同的，不然不能合并。</div><div>　　　　　　2.10、UNION[ALL]的使用</div><div>&nbsp;　　　　　　　　UNION：不使用关键字ALL，执行的时候会删除重复的记录，所有返回的行度是唯一的，</div><div>　　　　　　　　 UNION ALL：不删除重复航也不对结果进行自动排序。</div><div>&nbsp;　　　　　　　　格式：</div><div>　　　　　　　　　　　　SELECT 字段名,... FROM 表名</div><div>　　　　　　　　　　　　UNION[ALL]</div><div>　　　　　　　　　　　　SELECT 字段名,... FROM 表名</div><div>&nbsp;</div><div>　　　　　　　　问题一：查询所有价格小于9的水果的信息，查询s_id等于101个103所有水果的信息，使用UNION连接查询结果</div><div>　　　　　　　　　　　　SELECT s_id,f_name,f_price FROM fruits WHERE f_price &lt; 9&nbsp;</div><div>　　　　　　　　　　　　UNION ALL</div><div>　　　　　　　　　　　　SELECT s_id,f_name,f_price FROM fruits WHERE s_id = 101 OR s_id=103;</div><div>　　　　　　　　　　　　解释：显示的字段都是s_id,f_name,f_price，只是将两个的记录行合并到一张表中。仅仅增加的是记录行，而显示的字段还是那三个，没有增加，</div><div>　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　</div><div>　　　　　　　　　　　　使用UNION，而不用UNION ALL的话，重复的记录就会被删除掉。</div>','多表查询','MySQL；多表查询',0,'http://localhost:9010/picture/2019—01-31 21-46-43.jpg','2019-02-05 02-42-18',2,1,'MySQL多表查询（三）',2,'MySQL',9,NULL),(47,0,'<div>Spring注解实现原理&nbsp;</div><div><br></div><div>​【Spring如何使用注解机制完成自动装配】</div><div>Java实例构造时会调用默认父类无参构造方法，Spring正是利用了这一点，让\"操作元素的代码\"得以执行。</div><div>&nbsp;</div><div>【两种处理策略】</div><div>(1)类级别的注解：如@Component、@Repository、@Controller、@Service以及JavaEE6的@ManagedBean和@Named注解，都是添加在类上面的类级别注解。</div><div>Spring容器根据注解的过滤规则扫描读取注解Bean定义类，并将其注册到Spring IoC容器中。</div><div>&nbsp;</div><div>(2)类内部的注解：如@Autowire、@Value、@Resource以及EJB和WebService相关的注解等，都是添加在类内部的字段或者方法上的类内部注解。</div><div>SpringIoC容器通过Bean后置注解处理器解析Bean内部的注解。</div><div>&nbsp;</div><div>Spring实现@Autowire解析和注入的核心的类是通过AutowiredAnnotationBeanPostProcessor来实现的。</div><div>我们可以通过其方法列表看出，其中对字段的注入，对属性的注入，还有选择相应的构造方法来注入。</div><div>1，从构造方法的缓存中查询其构造方法</div><div>2，若缓存中不存在，则根据反射获取所有构造方法</div><div>3，遍历所有构造方法，查询器是否含有@Autowired属性</div><div>4，判断Autowired注解中指定了required属性 （required属性就是判断是否强依依赖）若存在required就使用默认构造方法。</div><div>5，返回指定的构造方法</div><div>&nbsp;</div><div>注入的时候则是通过inject方法来实现。</div><div>Spring对注解的支持主要都是通过反射来获取相应的注解，来做相应的处理，我们的工程中大部分都是使用@Service 和@Autowired来使用，其实我们还可以使用到其他的注解来加快我们的开发，满足我们的多样性需求。</div><div>&nbsp;</div><div>annotation是挺简单的东西.其实就是个声明。然后通过反射去取那些声明了值。</div><div>autowire其实也是这个意思。通过反射去看你autowire的方式，通过定义的方式，去给你声明的变量赋值。</div><div>&nbsp;</div><div>通过java的反射机制相关的API来访问Annotation信息。</div><div>相关类（框架或工具中的类）根据这些信息来决定如何使用该程序元素或改变它们的行为。</div><div>Java语言解释器在工作时会忽略这些Annotation，因此在JVM中这些Annotation是“不起作用”的，只能通过配套的工具才能对这些Annotation类型的信息进行访问和处理。</div><div>注解本身不做任何事情，只是像xml文件一样起到配置作用。</div><div>注解代表的是某种业务意义，注解背后处理器的工作原理如上源码实现：</div><div>——首先解析所有属性，判断属性上是否存在指定注解。</div><div>——如果存在则根据搜索规则取得bean，然后利用反射原理注入。</div><div>——如果标注在字段上面，也可以通过字段的反射技术取得注解，根据搜索规则取得bean，然后利用反射技术注入。</div><div><br></div><div>Spring 3.0 新增了另外两个实现类：AnnotationConfigApplicationContext 和 AnnotationConfigWebApplicationContext。从名字便可以看出，它们是为注解而生，直接依赖于注解作为容器配置信息来源的 IoC 容器初始化类。由于 AnnotationConfigWebApplicationContext 是 AnnotationConfigApplicationContext 的 web 版本，其用法与后者相比几乎没有什么差别，因此本文将以 AnnotationConfigApplicationContext 为例进行讲解。</div><div>&nbsp;</div><div>我们需要在用于指定配置信息的类上加上 @Configuration 注解，以明确指出该类是 Bean 配置的信息源。并且 Spring 对标注 Configuration 的类有如下要求：</div><div>配置类不能是 final 的；</div><div>配置类不能是本地化的，亦即不能将配置类定义在其他类的方法内部；</div><div>配置类必须有一个无参构造函数。</div><div>&nbsp;</div><div>AnnotationConfigApplicationContext 将配置类中标注了 @Bean 的方法的返回值识别为 Spring Bean，并注册到容器中，受 IoC 容器管理。@Bean 的作用等价于 XML 配置中的 &lt;bean/&gt; 标签。</div><div>&nbsp;</div><div>在一般的项目中，为了结构清晰，通常会根据软件的模块或者结构定义多个 XML 配置文件，然后再定义一个入口的配置文件，该文件使用 &lt;import/&gt; 将其他的配置文件组织起来。最后只需将该文件传给 ClassPathXmlApplicationContext 的构造函数即可。</div><div>&nbsp;</div><div>针对基于注解的配置，Spring 也提供了类似的功能，只需定义一个入口配置类，并在该类上使用 @Import 注解引入其他的配置类即可，最后只需要将该入口类传递给 AnnotationConfigApplicationContext。</div><div>@Configuration&nbsp;</div><div>@Import({BookStoreServiceConfig.class,BookStoreDaoConfig.class})&nbsp;</div><div>public class BookStoreConfig{ … }</div><div>http://zxf-noimp.iteye.com/blog/1071765</div><div>&nbsp;</div><div>【定义注解】</div><div>// 在运行时执行&nbsp;</div><div>@Retention(RetentionPolicy.RUNTIME)&nbsp;&nbsp;</div><div>// 注解适用地方(字段和方法)&nbsp;&nbsp;</div><div>@Target({ ElementType.FIELD, ElementType.METHOD })&nbsp;&nbsp;</div><div>public @interface ZxfResource {&nbsp;&nbsp;</div><div>&nbsp;&nbsp;</div><div>&nbsp; &nbsp; //注解的name属性&nbsp;&nbsp;</div><div>&nbsp; &nbsp; public String name() default \"\";&nbsp;&nbsp;</div><div>}</div><div>&nbsp;</div><div>【注解处理器】</div><div>public ClassPathXMLApplicationContext(String fileName) {&nbsp;&nbsp;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; //读取配置文件中管理的bean&nbsp;&nbsp;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; this.readXML(fileName);&nbsp;&nbsp;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; //实例化bean&nbsp;&nbsp;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; this.instancesBean();&nbsp;&nbsp;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; //注解处理器&nbsp;&nbsp;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; this.annotationInject();&nbsp;&nbsp;</div><div>&nbsp; &nbsp; }&nbsp;</div>','spring注解','spring；注解',0,'http://localhost:9010/picture/2019—01-31 21-46-34.jpg','2019-02-05 02-49-00',2,1,'spring注解实现原理',2,'Spring',12,NULL),(48,0,'<div>Spring工作原理&nbsp;</div><div>1、spring原理&nbsp;</div><div>&nbsp; &nbsp; &nbsp; 内部最核心的就是IOC了，动态注入，让一个对象的创建不用new了，可以自动的生产，这其实就是利用java里的反射，反射其实就是在运行时动态的去创建、调用对象，Spring就是在运行时，跟xml Spring的配置文件来动态的创建对象，和调用对象里的方法的 。&nbsp;&nbsp;</div><div>&nbsp; &nbsp; &nbsp; Spring还有一个核心就是AOP这个就是面向切面编程，可以为某一类对象 进行监督和控制（也就是 在调用这类对象的具体方法的前后去调用你指定的 模块）从而达到对一个模块扩充的功能。这些都是通过&nbsp; 配置类达到的。&nbsp;&nbsp;</div><div>&nbsp; &nbsp; &nbsp; Spring目的：就是让对象与对象（模块与模块）之间的关系没有通过代码来关联，都是通过配置类说明管理的（Spring根据这些配置 内部通过反射去动态的组装对象）&nbsp;&nbsp;</div><div>&nbsp; &nbsp; &nbsp; 要记住：Spring是一个容器，凡是在容器里的对象才会有Spring所提供的这些服务和功能。&nbsp;&nbsp;</div><div>Spring里用的最经典的一个设计模式就是：模板方法模式。(这里我都不介绍了，是一个很常用的设计模式)， Spring里的配置是很多的，很难都记住，但是Spring里的精华也无非就是以上的两点，把以上两点跟理解了 也就基本上掌握了Spring.</div><div><br></div><div>Spring AOP与IOC</div><div>一、 IoC(Inversion of control): 控制反转&nbsp;&nbsp;</div><div>1、IoC：&nbsp;&nbsp;</div><div>概念：控制权由对象本身转向容器；由容器根据配置文件去创建实例并创建各个实例之间的依赖关系&nbsp;&nbsp;</div><div>核心：bean工厂；在Spring中，bean工厂创建的各个实例称作bean&nbsp;&nbsp;</div><div>二、AOP(Aspect-Oriented Programming): 面向方面编程&nbsp;&nbsp;</div><div>1、 代理的两种方式：&nbsp;&nbsp;</div><div>静态代理：&nbsp;&nbsp;</div><div> 针对每个具体类分别编写代理类；&nbsp;&nbsp;</div><div> 针对一个接口编写一个代理类；&nbsp;&nbsp;</div><div>动态代理：&nbsp;&nbsp;</div><div>针对一个方面编写一个InvocationHandler，然后借用JDK反射包中的Proxy类为各种接口动态生成相应的代理类</div><div>&nbsp;</div><div>2、动态代理:</div><div>不用写代理类，虚拟机根据真实对象实现的接口产生一个类，通过类实例化一个动态代理，在实例化动态代理时将真实对象及装备注入到动态代理中，向客户端公开的是动态代理，当客户端调用动态代理方法时，动态代理根据类的反射得到真实对象的Method,调用装备的invoke方法，将动态代理、 Method、方法参数传与装备的invoke方法，invoke方法在唤起method方法前或后做一些处理。&nbsp; &nbsp; &nbsp;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1、产生动态代理的类:</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; java.lang.refect.Proxy</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2、装备必须实现InvocationHandler接口实现invoke方法</div><div>3、反射</div><div>&nbsp; &nbsp; 什么是类的返射?</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 通过类说明可以得到类的父类、实现的接口、内部类、构造函数、方法、属性并可以根据构造器实例化一个对象，唤起一个方法，取属性值，改属性值。如何得到一个类说明：</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Class cls=类.class;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Class cls=对象.getClass();</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Class.forName(\"类路径\");</div><div>&nbsp; &nbsp; &nbsp; &nbsp;如何得到一个方法并唤起它?</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Class cls=类.class;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Constructor cons=cls.getConstructor(new Class[]{String.class});</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Object obj=cons.newInstance(new Object[]{\"aaa\"});</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Method method=cls.getMethod(\"方法名\",new Class[]{String.class,Integer.class});</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; method.invoke(obj,new Object[]{\"aa\",new Integer(1)});&nbsp;</div><div>4、spring的三种注入方式是什么?</div><div>&nbsp; &nbsp; &nbsp; &nbsp; setter</div><div>&nbsp; &nbsp; &nbsp; &nbsp; interface</div><div>&nbsp; &nbsp; &nbsp; &nbsp; constructor</div><div>5、spring的核心接口及核类配置文件是什么?</div><div>&nbsp; &nbsp; &nbsp; &nbsp; FactoryBean:工厂bean主要实现ioc/di</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ApplicationContext ac=new FileXmlApplicationContext(\"applicationContext.xml\");</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Object obj=ac.getBean(\"id值\");</div><div>6、Spring框架的7个模块</div><div><br></div><div><br></div><div>Spring 框架是一个分层架构，由 7 个定义良好的模块组成。Spring 模块构建在核心容器之上，核心容器定义了创建、配置和管理 bean 的方式，组成 Spring 框架的每个模块（或组件）都可以单独存在，或者与其他一个或多个模块联合实现。每个模块的功能如下：</div><div>&nbsp; &nbsp; &nbsp;核心容器：核心容器提供 Spring 框架的基本功能。核心容器的主要组件是 BeanFactory，它是工厂模式的实现。BeanFactory 使用控制反转 （IOC）模式将应用程序的配置和依赖性规范与实际的应用程序代码分开。</div><div>&nbsp; &nbsp; &nbsp;Spring 上下文：Spring 上下文是一个配置文件，向 Spring 框架提供上下文信息。Spring 上下文包括企业服务，例如 JNDI、EJB、电子邮件、国际化、校验和调度功能。</div><div>&nbsp; &nbsp; &nbsp;Spring AOP：通过配置管理特性，Spring AOP 模块直接将面向方面的编程功能集成到了 Spring 框架中。所以，可以很容易地使 Spring 框架管理的任何对象支持 AOP。Spring AOP 模块为基于 Spring 的应用程序中的对象提供了事务管理服务。通过使用 Spring AOP，不用依赖 EJB 组件，就可以将声明性事务管理集成到应用程序中。</div><div>&nbsp; &nbsp; &nbsp;Spring DAO：JDBC DAO 抽象层提供了有意义的异常层次结构，可用该结构来管理异常处理和不同数据库供应商抛出的错误消息。异常层次结构简化了错误处理，并且极大地降低了需要编写的异常代码数量（例如打开和关闭连接）。Spring DAO 的面向 JDBC 的异常遵从通用的 DAO 异常层次结构。</div><div>&nbsp; &nbsp; &nbsp;Spring ORM：Spring 框架插入了若干个 ORM 框架，从而提供了 ORM 的对象关系工具，其中包括 JDO、Hibernate 和 iBatis SQL Map。所有这些都遵从 Spring 的通用事务和 DAO 异常层次结构。</div><div>&nbsp; &nbsp; &nbsp;Spring Web 模块：Web 上下文模块建立在应用程序上下文模块之上，为基于 Web 的应用程序提供了上下文。所以，Spring 框架支持与 Jakarta Struts 的集成。Web 模块还简化了处理多部分请求以及将请求参数绑定到域对象的工作。</div><div>&nbsp; &nbsp; &nbsp;Spring MVC 框架：MVC 框架是一个全功能的构建 Web 应用程序的 MVC 实现。通过策略接口，MVC 框架变成为高度可配置的，MVC 容纳了大量视图技术，其中包括 JSP、Velocity、Tiles、iText 和 POI。</div><div>Spring 框架的功能可以用在任何 J2EE 服务器中，大多数功能也适用于不受管理的环境。Spring 的核心要点是：支持不绑定到特定 J2EE 服务的可重用业务和数据访问对象。毫无疑问，这样的对象可以在不同 J2EE 环境 （Web 或 EJB）、独立应用程序、测试环境之间重用。</div>','spring工作原理','spring',1,'http://localhost:9010/picture/2019—01-31 21-46-34.jpg','2019-02-05 02-51-46',2,1,'spring工作原理',2,'Spring',12,NULL),(49,0,'<div>SSH&nbsp;</div><div>Ssh为 struts+spring+hibernate的一个集成框架，是目前较流行的一种Web应用程序开源框架。</div><div>集成SSH框架的系统从职责上分为四层：表示层、业务逻辑层、数据持久层和域模块层，以帮助开发人员在短期内搭建结构清晰、可复用性好、维护方便的Web应用程序。其中使用Struts作为系统的整体基础架构，负责MVC的分离，在Struts框架的模型部分，控制业务跳转，利用Hibernate框架对持久层提供支持，Spring做管理，管理struts和hibernate。具体做法是：用面向对象的分析方法根据需求提出一些模型，将这些模型实现为基本的Java对象，然后编写基本的DAO(Data Access Objects)接口，并给出Hibernate的DAO实现，采用Hibernate架构实现的DAO类来实现Java类与数据库之间的转换和访问，最后由Spring做管理，管理struts和hibernate。</div><div>业务流程</div><div>系统的基本业务流程是： 在表示层中，首先通过JSP页面实现交互界面，负责接收请求(Request)和传送响应(Response)，然后Struts根据配置文件(struts-config.xml)将ActionServlet接收到的Request委派给相应的Action处理。在业务层中，管理服务组件的Spring IoC容器负责向Action提供业务模型(Model)组件和该组件的协作对象数据处理(DAO)组件完成业务逻辑，并提供事务处理、缓冲池等容器组件以提升系统性能和保证数据的完整性。而在持久层中，则依赖于Hibernate的对象化映射和数据库交互，处理DAO组件请求的数据，并返回处理结果。</div><div>采用上述开发模型，不仅实现了视图、控制器与模型的彻底分离，而且还实现了业务逻辑层与持久层的分离。这样无论前端如何变化，模型层只需很少的改动，并且数据库的变化也不会对前端有所影响，大大提高了系统的可复用性。而且由于不同层之间耦合度小，有利于团队成员并行工作，大大提高了开发效率。</div><div><br></div><div>框架结构</div><div><br></div><div>Struts1</div><div>Struts对Model，View和Controller都提供了对应的组件。</div><div>ActionServlet，这个类是Struts1的核心控制器，负责拦截来自用户的请求。</div><div>Action，这个类通常由用户提供，该控制器负责接收来自ActionServlet的请求，并根据该请求调用模型的业务逻辑方法处理请求，并将处理结果返回给JSP页面显示。</div><div>Model部分：</div><div>由ActionForm和JavaBean组成，其中ActionForm用于将用户的请求参数封装成ActionForm对象，该对象被ActionServlet转发给Action，Action根据ActionForm里面的请求参数处理用户的请求。</div><div>JavaBean则封装了底层的业务逻辑，包括数据库访问等。</div><div>View部分：</div><div>该部分采用JSP（或HTML、PHP……）实现。</div><div>Struts提供了丰富的标签库，通过标签库可以减少脚本的使用，自定义的标签库可以实现与Model的有效交互，并增加了现实功能。对应上图的JSP部分。</div><div>Controller组件：</div><div>Controller组件有两个部分组成——系统核心控制器，业务逻辑控制器。</div><div>系统核心控制器，对应上边的ActionServlet。该控制器继承了HttpServlet类，因此可以配置成标注的Servlet。该控制器负责拦截所有的HTTP请求，然后根据用户请求决定是否要转给业务逻辑控制器。</div><div>业务逻辑控制器，负责处理用户请求，本身不具备处理能力，而是调用Model来完成处理。对应Action部分。</div><div><br></div><div>Spring</div><div>Spring是一个开源框架，它由Rod Johnson创建。它是为了解决企业应用开发的复杂性而创建的。Spring使用基本的JavaBean来完成以前只可能由EJB完成的事情。然而，Spring的用途不仅限于服务器端的开发。从简单性、可测试性和松耦合的角度而言，任何Java应用都可以从Spring中受益。</div><div>目的：解决企业应用开发的复杂性</div><div>功能：使用基本的JavaBean代替EJB，并提供了更多的企业应用功能</div><div>范围：任何Java应用</div><div>简单来说，Spring是一个轻量级的控制反转(IoC)和面向切面(AOP)的容器框架。</div><div>轻量——从大小与开销两方面而言Spring都是轻量的。完整的Spring框架可以在一个大小只有1MB多的JAR文件里发布。并且Spring所需的处理开销也是微不足道的。此外，Spring是非侵入式的：典型地，Spring应用中的对象不依赖于Spring的特定类。</div><div>控制反转——Spring通过一种称作控制反转（IoC）的技术促进了松耦合。当应用了IoC，一个对象依赖的其它对象会通过被动的方式传递进来，而不是这个对象自己创建或者查找依赖对象。你可以认为IoC与JNDI相反——不是对象从容器中查找依赖，而是容器在对象初始化时不等对象请求就主动将依赖传递给它。</div><div>面向切面——Spring提供了面向切面编程的丰富支持，允许通过分离应用的业务逻辑与系统级服务（例如审计（auditing）和事务（transaction）管理）进行内聚性的开发。应用对象只实现它们应该做的——完成业务逻辑——仅此而已。它们并不负责（甚至是意识）其它的系统级关注点，例如日志或事务支持。</div><div>容器——Spring包含并管理应用对象的配置和生命周期，在这个意义上它是一种容器，你可以配置你的每个bean如何被创建——基于一个可配置原型（prototype），你的bean可以创建一个单独的实例或者每次需要时都生成一个新的实例——以及它们是如何相互关联的。然而，Spring不应该被混同于传统的重量级的EJB容器，它们经常是庞大与笨重的，难以使用。</div><div>框架——Spring可以将简单的组件配置、组合成为复杂的应用。在Spring中，应用对象被声明式地组合，典型地是在一个XML文件里。Spring也提供了很多基础功能（事务管理、持久化框架集成等等），将应用逻辑的开发留给了你。</div><div>所有Spring的这些特征使你能够编写更干净、更可管理、并且更易于测试的代码。它们也为Spring中的各种模块提供了基础支持。</div><div><br></div><div>Hibernate</div><div>Hibernate是一个开放源代码的对象关系映射框架，它对JDBC进行了非常轻量级的对象封装，使得Java程序员可以随心所欲的使用对象编程思维来操纵数据库。 Hibernate可以应用在任何使用JDBC的场合，既可以在Java的客户端程序使用，也可以在Servlet/JSP的Web应用中使用，最具革命意义的是，Hibernate可以在应用EJB的J2EE架构中取代CMP，完成数据持久化的重任。</div><div>Hibernate的核心接口一共有5个，分别为:Session、SessionFactory、Transaction、Query和Configuration。这5个核心接口在任何开发中都会用到。通过这些接口，不仅可以对持久化对象进行存取，还能够进行事务控制。下面对这五个核心接口分别加以介绍。</div><div>·Session接口:Session接口负责执行被持久化对象的CRUD操作(CRUD的任务是完成与数据库的交流，包含了很多常见的SQL语句。)。但需要注意的是Session对象是非线程安全的。同时，Hibernate的session不同于JSP应用中的HttpSession。这里当使用session这个术语时，其实指的是Hibernate中的session，而以后会将HttpSession对象称为用户session。</div><div>·SessionFactory接口:SessionFactory接口负责初始化Hibernate。它充当数据存储源的代理，并负责创建Session对象。这里用到了工厂模式。需要注意的是SessionFactory并不是轻量级的，因为一般情况下，一个项目通常只需要一个SessionFactory就够，当需要操作多个数据库时，可以为每个数据库指定一个SessionFactory。</div><div>·Configuration接口:Configuration接口负责配置并启动Hibernate，创建SessionFactory对象。在Hibernate的启动的过程中，Configuration类的实例首先定位映射文档位置、读取配置，然后创建SessionFactory对象。</div><div>·Transaction接口:Transaction接口负责事务相关的操作。它是可选的，开发人员也可以设计编写自己的底层事务处理代码。</div><div>·Query和Criteria接口:Query和Criteria接口负责执行各种数据库查询。它可以使用HQL语言或SQL语句两种表达方式。</div>','SSH','SSH',0,'http://localhost:9010/picture/2019—01-31 21-46-34.jpg','2019-02-05 02-54-19',2,1,'spring之SSH',2,'Spring',12,NULL),(50,0,'<div>一、事务的基本原理</div><div>Spring事务 的本质其实就是数据库对事务的支持，没有数据库的事务支持，spring是无法提供事务功能的。对于纯JDBC操作数据库，想要用到事务，可以按照以下步骤进行：</div><div>&nbsp; &nbsp; 获取连接 Connection con = DriverManager.getConnection()</div><div>&nbsp; &nbsp; 开启事务con.setAutoCommit(true/false);</div><div>&nbsp; &nbsp; 执行CRUD</div><div>&nbsp; &nbsp; 提交事务/回滚事务 con.commit() / con.rollback();</div><div>&nbsp; &nbsp; 关闭连接 conn.close();</div><div>使用Spring的事务管理功能后，我们可以不再写步骤 2 和 4 的代码，而是由Spirng 自动完成。 那么Spring是如何在我们书写的 CRUD 之前和之后开启事务和关闭事务的呢？解决这个问题，也就可以从整体上理解Spring的事务管理实现原理了。下面简单地介绍下，注解方式为例子</div><div>&nbsp; &nbsp; 配置文件开启注解驱动，在相关的类和方法上通过注解@Transactional标识。</div><div>&nbsp; &nbsp; spring 在启动的时候会去解析生成相关的bean，这时候会查看拥有相关注解的类和方法，并且为这些类和方法生成代理，并根据@Transaction的相关参数进行相关配置注入，这样就在代理中为我们把相关的事务处理掉了（开启正常提交事务，异常回滚事务）。</div><div>&nbsp; &nbsp; 真正的数据库层的事务提交和回滚是通过binlog或者redo log实现的。</div><div>二、Spring 事务的传播属性</div><div>所谓spring事务的传播属性，就是定义在存在多个事务同时存在的时候，spring应该如何处理这些事务的行为。这些属性在TransactionDefinition中定义，具体常量的解释见下表：</div><div>常量名称&nbsp; &nbsp; &nbsp;常量解释</div><div>PROPAGATION_REQUIRED&nbsp; &nbsp; &nbsp;支持当前事务，如果当前没有事务，就新建一个事务。这是最常见的选择，也是 Spring 默认的事务的传播。</div><div>PROPAGATION_REQUIRES_NEW&nbsp; &nbsp; &nbsp;新建事务，如果当前存在事务，把当前事务挂起。新建的事务将和被挂起的事务没有任何关系，是两个独立的事务，外层事务失败回滚之后，不能回滚内层事务执行的结果，内层事务失败抛出异常，外层事务捕获，也可以不处理回滚操作</div><div>PROPAGATION_SUPPORTS&nbsp; &nbsp; &nbsp;支持当前事务，如果当前没有事务，就以非事务方式执行。</div><div>PROPAGATION_MANDATORY&nbsp; &nbsp; &nbsp;支持当前事务，如果当前没有事务，就抛出异常。</div><div>PROPAGATION_NOT_SUPPORTED&nbsp; &nbsp; &nbsp;以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</div><div>PROPAGATION_NEVER&nbsp; &nbsp; &nbsp;以非事务方式执行，如果当前存在事务，则抛出异常。</div><div>PROPAGATION_NESTED&nbsp; &nbsp; &nbsp;</div><div>如果一个活动的事务存在，则运行在一个嵌套的事务中。如果没有活动事务，则按REQUIRED属性执行。它使用了一个单独的事务，这个事务拥有多个可以回滚的保存点。内部事务的回滚不会对外部事务造成影响。它只对DataSourceTransactionManager事务管理器起效。</div><div>三、数据库隔离级别</div><div>隔离级别&nbsp; &nbsp; &nbsp;隔离级别的值&nbsp; &nbsp; &nbsp;导致的问题</div><div>Read-Uncommitted&nbsp; &nbsp; &nbsp;0&nbsp; &nbsp; &nbsp;导致脏读</div><div>Read-Committed&nbsp; &nbsp; &nbsp;1&nbsp; &nbsp; &nbsp;避免脏读，允许不可重复读和幻读</div><div>Repeatable-Read&nbsp; &nbsp; &nbsp;2&nbsp; &nbsp; &nbsp;避免脏读，不可重复读，允许幻读</div><div>Serializable&nbsp; &nbsp; &nbsp;3&nbsp; &nbsp; &nbsp;串行化读，事务只能一个一个执行，避免了脏读、不可重复读、幻读。执行效率慢，使用时慎重</div><div>脏读：一事务对数据进行了增删改，但未提交，另一事务可以读取到未提交的数据。如果第一个事务这时候回滚了，那么第二个事务就读到了脏数据。</div><div>不可重复读：一个事务中发生了两次读操作，第一次读操作和第二次操作之间，另外一个事务对数据进行了修改，这时候两次读取的数据是不一致的。</div><div>幻读：第一个事务对一定范围的数据进行批量修改，第二个事务在这个范围增加一条数据，这时候第一个事务就会丢失对新增数据的修改。</div><div>总结：</div><div>隔离级别越高，越能保证数据的完整性和一致性，但是对并发性能的影响也越大。</div><div>大多数的数据库默认隔离级别为 Read Commited，比如 SqlServer、Oracle</div><div>少数数据库默认隔离级别为：Repeatable Read 比如： MySQL InnoDB</div><div>四、Spring中的隔离级别</div><div>常量&nbsp; &nbsp; &nbsp;解释</div><div>ISOLATION_DEFAULT&nbsp; &nbsp; &nbsp;这是个 PlatfromTransactionManager 默认的隔离级别，使用数据库默认的事务隔离级别。另外四个与 JDBC 的隔离级别相对应。</div><div>ISOLATION_READ_UNCOMMITTED&nbsp; &nbsp; &nbsp;这是事务最低的隔离级别，它充许另外一个事务可以看到这个事务未提交的数据。这种隔离级别会产生脏读，不可重复读和幻像读。</div><div>ISOLATION_READ_COMMITTED&nbsp; &nbsp; &nbsp;保证一个事务修改的数据提交后才能被另外一个事务读取。另外一个事务不能读取该事务未提交的数据。</div><div>ISOLATION_REPEATABLE_READ&nbsp; &nbsp; &nbsp;这种事务隔离级别可以防止脏读，不可重复读。但是可能出现幻像读。</div><div>ISOLATION_SERIALIZABLE&nbsp; &nbsp; &nbsp;这是花费最高代价但是最可靠的事务隔离级别。事务被处理为顺序执行。</div><div>五、事务的嵌套</div><div>通过上面的理论知识的铺垫，我们大致知道了数据库事务和spring事务的一些属性和特点，接下来我们通过分析一些嵌套事务的场景，来深入理解spring事务传播的机制。</div><div>假设外层事务 Service A 的 Method A() 调用 内层Service B 的 Method B()</div><div>PROPAGATION_REQUIRED(spring 默认)</div><div>如果ServiceB.methodB() 的事务级别定义为 PROPAGATION_REQUIRED，那么执行 ServiceA.methodA() 的时候spring已经起了事务，这时调用 ServiceB.methodB()，ServiceB.methodB() 看到自己已经运行在 ServiceA.methodA() 的事务内部，就不再起新的事务。</div><div>假如 ServiceB.methodB() 运行的时候发现自己没有在事务中，他就会为自己分配一个事务。</div><div>这样，在 ServiceA.methodA() 或者在 ServiceB.methodB() 内的任何地方出现异常，事务都会被回滚。</div><div>PROPAGATION_REQUIRES_NEW</div><div>比如我们设计 ServiceA.methodA() 的事务级别为 PROPAGATION_REQUIRED，ServiceB.methodB() 的事务级别为 PROPAGATION_REQUIRES_NEW。</div><div>那么当执行到 ServiceB.methodB() 的时候，ServiceA.methodA() 所在的事务就会挂起，ServiceB.methodB() 会起一个新的事务，等待 ServiceB.methodB() 的事务完成以后，它才继续执行。</div><div>他与 PROPAGATION_REQUIRED 的事务区别在于事务的回滚程度了。因为 ServiceB.methodB() 是新起一个事务，那么就是存在两个不同的事务。如果 ServiceB.methodB() 已经提交，那么 ServiceA.methodA() 失败回滚，ServiceB.methodB() 是不会回滚的。如果 ServiceB.methodB() 失败回滚，如果他抛出的异常被 ServiceA.methodA() 捕获，ServiceA.methodA() 事务仍然可能提交(主要看B抛出的异常是不是A会回滚的异常)。</div><div>PROPAGATION_SUPPORTS</div><div>假设ServiceB.methodB() 的事务级别为 PROPAGATION_SUPPORTS，那么当执行到ServiceB.methodB()时，如果发现ServiceA.methodA()已经开启了一个事务，则加入当前的事务，如果发现ServiceA.methodA()没有开启事务，则自己也不开启事务。这种时候，内部方法的事务性完全依赖于最外层的事务。</div><div>PROPAGATION_NESTED</div><div>现在的情况就变得比较复杂了, ServiceB.methodB() 的事务属性被配置为 PROPAGATION_NESTED, 此时两者之间又将如何协作呢?&nbsp; ServiceB#methodB 如果 rollback, 那么内部事务(即 ServiceB#methodB) 将回滚到它执行前的 SavePoint 而外部事务(即 ServiceA#methodA) 可以有以下两种处理方式:</div><div>a、捕获异常，执行异常分支逻辑</div><div>void methodA() {&nbsp;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; try {&nbsp;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ServiceB.methodB();&nbsp;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; } catch (SomeException) {&nbsp;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 执行其他业务, 如 ServiceC.methodC();&nbsp;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;</div><div>&nbsp; &nbsp; }</div><div>这种方式也是嵌套事务最有价值的地方, 它起到了分支执行的效果, 如果 ServiceB.methodB 失败, 那么执行 ServiceC.methodC(), 而 ServiceB.methodB 已经回滚到它执行之前的 SavePoint, 所以不会产生脏数据(相当于此方法从未执行过), 这种特性可以用在某些特殊的业务中, 而 PROPAGATION_REQUIRED 和 PROPAGATION_REQUIRES_NEW 都没有办法做到这一点。</div><div>b、 外部事务回滚/提交 代码不做任何修改, 那么如果内部事务(ServiceB#methodB) rollback, 那么首先 ServiceB.methodB 回滚到它执行之前的 SavePoint(在任何情况下都会如此), 外部事务(即 ServiceA#methodA) 将根据具体的配置决定自己是 commit 还是 rollback</div><div>另外三种事务传播属性基本用不到，在此不做分析。</div><div>六、总结</div><div>对于项目中需要使用到事务的地方，我建议开发者还是使用spring的TransactionCallback接口来实现事务，不要盲目使用spring事务注解，如果一定要使用注解，那么一定要对spring事务的传播机制和隔离级别有个详细的了解，否则很可能发生意想不到的效果。</div>','事物原理','spring；事物原理',0,'http://localhost:9010/picture/2019—01-31 21-46-34.jpg','2019-02-05 02-55-59',2,1,'spring之事物原理',2,'Spring',12,NULL),(51,0,'<div>什么是AOP</div><div>AOP（Aspect-OrientedProgramming，面向方面编程），可以说是OOP（Object-Oriented Programing，面向对象编程）的补充和完善。OOP引入封装、继承和多态性等概念来建立一种对象层次结构，用以模拟公共行为的一个集合。当我们需要为分散的对象引入公共行为的时候，OOP则显得无能为力。也就是说，OOP允许你定义从上到下的关系，但并不适合定义从左到右的关系。例如日志功能。日志代码往往水平地散布在所有对象层次中，而与它所散布到的对象的核心功能毫无关系。对于其他类型的代码，如安全性、异常处理和透明的持续性也是如此。这种散布在各处的无关的代码被称为横切（cross-cutting）代码，在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。</div><div>&nbsp;</div><div>而AOP技术则恰恰相反，它利用一种称为“横切”的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其名为“Aspect”，即方面。所谓“方面”，简单地说，就是将那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可操作性和可维护性。AOP代表的是一个横向的关系，如果说“对象”是一个空心的圆柱体，其中封装的是对象的属性和行为；那么面向方面编程的方法，就仿佛一把利刃，将这些空心圆柱体剖开，以获得其内部的消息。而剖开的切面，也就是所谓的“方面”了。然后它又以巧夺天功的妙手将这些剖开的切面复原，不留痕迹。</div><div>&nbsp;</div><div>使用“横切”技术，AOP把软件系统分为两个部分：核心关注点和横切关注点。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。横切关注点的一个特点是，他们经常发生在核心关注点的多处，而各处都基本相似。比如权限认证、日志、事务处理。Aop 的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。正如Avanade公司的高级方案构架师Adam Magee所说，AOP的核心思想就是“将应用程序中的商业逻辑同对其提供支持的通用服务进行分离。”</div><div>&nbsp;</div><div>实现AOP的技术，主要分为两大类：一是采用动态代理技术，利用截取消息的方式，对该消息进行装饰，以取代原有对象行为的执行；二是采用静态织入的方式，引入特定的语法创建“方面”，从而使得编译器可以在编译期间织入有关“方面”的代码。</div><div>&nbsp;</div><div>AOP使用场景</div><div>AOP用来封装横切关注点，具体可以在下面的场景中使用:</div><div>&nbsp;</div><div>Authentication 权限</div><div>Caching 缓存</div><div>Context passing 内容传递</div><div>Error handling 错误处理</div><div>Lazy loading　懒加载</div><div>Debugging　　调试</div><div>logging, tracing, profiling and monitoring　记录跟踪　优化　校准</div><div>Performance optimization　性能优化</div><div>Persistence　　持久化</div><div>Resource pooling　资源池</div><div>Synchronization　同步</div><div>Transactions 事务</div><div>&nbsp;</div><div>AOP相关概念</div><div>方面（Aspect）：一个关注点的模块化，这个关注点实现可能另外横切多个对象。事务管理是J2EE应用中一个很好的横切关注点例子。方面用Spring的 Advisor或拦截器实现。</div><div>&nbsp;</div><div>连接点（Joinpoint）: 程序执行过程中明确的点，如方法的调用或特定的异常被抛出。</div><div>&nbsp;</div><div>通知（Advice）: 在特定的连接点，AOP框架执行的动作。各种类型的通知包括“around”、“before”和“throws”通知。通知类型将在下面讨论。许多AOP框架包括Spring都是以拦截器做通知模型，维护一个“围绕”连接点的拦截器链。Spring中定义了四个advice: BeforeAdvice, AfterAdvice, ThrowAdvice和DynamicIntroductionAdvice</div><div>&nbsp;</div><div>切入点（Pointcut）: 指定一个通知将被引发的一系列连接点的集合。AOP框架必须允许开发者指定切入点：例如，使用正则表达式。 Spring定义了Pointcut接口，用来组合MethodMatcher和ClassFilter，可以通过名字很清楚的理解， MethodMatcher是用来检查目标类的方法是否可以被应用此通知，而ClassFilter是用来检查Pointcut是否应该应用到目标类上</div><div>&nbsp;</div><div>引入（Introduction）: 添加方法或字段到被通知的类。 Spring允许引入新的接口到任何被通知的对象。例如，你可以使用一个引入使任何对象实现 IsModified接口，来简化缓存。Spring中要使用Introduction, 可有通过DelegatingIntroductionInterceptor来实现通知，通过DefaultIntroductionAdvisor来配置Advice和代理类要实现的接口</div><div>&nbsp;</div><div>目标对象（Target Object）: 包含连接点的对象。也被称作被通知或被代理对象。POJO</div><div>&nbsp;</div><div>AOP代理（AOP Proxy）: AOP框架创建的对象，包含通知。 在Spring中，AOP代理可以是JDK动态代理或者CGLIB代理。</div><div>&nbsp;</div><div>织入（Weaving）: 组装方面来创建一个被通知对象。这可以在编译时完成（例如使用AspectJ编译器），也可以在运行时完成。Spring和其他纯Java AOP框架一样，在运行时完成织入。</div><div>&nbsp;</div><div>如何使用Spring AOP</div><div>&nbsp;</div><div>可以通过配置文件或者编程的方式来使用Spring AOP。</div><div>&nbsp;</div><div>配置可以通过xml文件来进行，大概有四种方式：</div><div>1.&nbsp; &nbsp; &nbsp; &nbsp; 配置ProxyFactoryBean，显式地设置advisors, advice, target等</div><div>2.&nbsp; &nbsp; &nbsp; &nbsp; 配置AutoProxyCreator，这种方式下，还是如以前一样使用定义的bean，但是从容器中获得的其实已经是代理对象</div><div>3.&nbsp; &nbsp; &nbsp; &nbsp; 通过&lt;aop:config&gt;来配置</div><div>4.&nbsp; &nbsp; &nbsp; &nbsp; 通过&lt;aop: aspectj-autoproxy&gt;来配置，使用AspectJ的注解来标识通知及切入点</div><div>&nbsp;</div><div>也可以直接使用ProxyFactory来以编程的方式使用Spring AOP，通过ProxyFactory提供的方法可以设置target对象, advisor等相关配置，最终通过 getProxy()方法来获取代理对象</div><div>&nbsp;</div><div>具体使用的示例可以google. 这里略去</div><div>&nbsp;</div><div>Spring AOP代理对象的生成</div><div>&nbsp;</div><div>Spring提供了两种方式来生成代理对象: JDKProxy和Cglib，具体使用哪种方式生成由AopProxyFactory根据AdvisedSupport对象的配置来决定。默认的策略是如果目标类是接口，则使用JDK动态代理技术，否则使用Cglib来生成代理。</div><div>原文即实例地址：<a href=\"https://www.cnblogs.com/oumyye/p/4467276.html\" target=\"_blank\">https://www.cnblogs.com/oumyye/p/4467276.html</a></div>','AOP原理','spring；AOP',0,'http://localhost:9010/picture/2019—01-31 21-46-34.jpg','2019-02-05 02-58-27',2,1,'spring之AOP原理',2,'Spring',12,NULL),(52,0,'<div>spring-security原理学习&nbsp;</div><div><br></div><div>spring security使用分类：</div><div>如何使用spring security，相信百度过的都知道，总共有四种用法，从简到深为：1、不用数据库，全部数据写在配置文件，这个也是官方文档里面的demo；2、使用数据库，根据spring security默认实现代码设计数据库，也就是说数据库已经固定了，这种方法不灵活，而且那个数据库设计得很简陋，实用性差；3、spring security和Acegi不同，它不能修改默认filter了，但支持插入filter，所以根据这个，我们可以插入自己的filter来灵活使用；4、暴力手段，修改源码，前面说的修改默认filter只是修改配置文件以替换filter而已，这种是直接改了里面的源码，但是这种不符合OO设计原则，而且不实际，不可用。</div><div>本文面向读者：</div><div>因为本文准备介绍第三种方法，所以面向的读者是已经具备了spring security基础知识的。不过不要紧，读者可以先看一下这个教程，看完应该可以使用第二种方法开发了。</div><div>spring security的简单原理：</div><div>使用众多的拦截器对url拦截，以此来管理权限。但是这么多拦截器，笔者不可能对其一一来讲，主要讲里面核心流程的两个。 首先，权限管理离不开登陆验证的，所以登陆验证拦截器AuthenticationProcessingFilter要讲； 还有就是对访问的资源管理吧，所以资源管理拦截器AbstractSecurityInterceptor要讲； 但拦截器里面的实现需要一些组件来实现，所以就有了AuthenticationManager、accessDecisionManager等组件来支撑。&nbsp; &nbsp; &nbsp;现在先大概过一遍整个流程，用户登陆，会被AuthenticationProcessingFilter拦截，调用AuthenticationManager的实现，而且AuthenticationManager会调用ProviderManager来获取用户验证信息（不同的Provider调用的服务不同，因为这些信息可以是在数据库上，可以是在LDAP服务器上，可以是xml配置文件上等），如果验证通过后会将用户的权限信息封装一个User放到spring的全局缓存SecurityContextHolder中，以备后面访问资源时使用。 访问资源（即授权管理），访问url时，会通过AbstractSecurityInterceptor拦截器拦截，其中会调用FilterInvocationSecurityMetadataSource的方法来获取被拦截url所需的全部权限，在调用授权管理器AccessDecisionManager，这个授权管理器会通过spring的全局缓存SecurityContextHolder获取用户的权限信息，还会获取被拦截的url和被拦截url所需的全部权限，然后根据所配的策略（有：一票决定，一票否定，少数服从多数等），如果权限足够，则返回，权限不够则报错并调用权限不足页面。&nbsp; &nbsp; &nbsp;虽然讲得好像好复杂，读者们可能有点晕，不过不打紧，真正通过代码的讲解在后面，读者可以看完后面的代码实现，再返回看这个简单的原理，可能会有不错的收获。</div><div>原文即实例地址：<a href=\"https://www.cnblogs.com/quyixuanblog/p/5213503.html\" target=\"_blank\">https://www.cnblogs.com/quyixuanblog/p/5213503.html</a></div>','security','spring；security',4,'http://localhost:9010/picture/2019—01-31 21-46-34.jpg','2019-02-05 03-04-41',2,1,'spring之security',2,'Spring',12,NULL),(53,0,'链接地址：<a href=\"https://www.cnblogs.com/3xmq/p/springboot.html\" target=\"_blank\">https://www.cnblogs.com/3xmq/p/springboot.html</a>','spring boot面试题','spring boot',0,'http://localhost:9010/picture/2019—01-31 21-46-12.jpg','2019-02-05 03-06-43',2,1,'spring boot面试题',2,'Spring Boot',10,NULL),(54,0,'<p>spring boot 是什么&nbsp;</p><p>什么是 Spring Boot</p><p>Spring Boot 特性</p><p>使用 Spring 项目引导页面可以在几秒构建一个项目</p><p>方便对外输出各种形式的服务，如 REST API、WebSocket、Web、Streaming、Tasks</p><p>非常简洁的安全策略集成</p><p>支持关系数据库和非关系数据库</p><p>支持运行期内嵌容器，如 Tomcat、Jetty</p><p>强大的开发包，支持热启动</p><p>自动管理依赖</p><p>自带应用监控</p><p>支持各种 IDE，如 IntelliJ IDEA 、NetBeans</p><p>Spring Boot 使编码变简单，Spring Boot 提供了丰富的解决方案，快速集成各种解决方案提升开发效率。</p><p>Spring Boot 使配置变简单，Spring Boot 提供了丰富的 Starters，集成主流开源产品往往只需要简单的配置即可。</p><p>Spring Boot 使部署变简单，Spring Boot 本身内嵌启动容器，仅仅需要一个命令即可启动项目，结合 Jenkins 、Docker 自动化运维非常容易实现。</p><p>Spring Boot 使监控变简单，Spring Boot 自带监控组件，使用 Actuator 轻松监控服务各项状态。</p><p>使用 Spring Boot 的优势</p><p>Spring Boot 让开发变得更简单</p><p>Spring Boot 对开发效率的提升是全方位的，我们可以简单做一下对比：</p><p>在没有使用 Spring Boot 之前我们开发一个 web 项目需要做哪些工作：</p><p>1）配置 web.xml，加载 Spring 和 Spring mvc</p><p>2）配置数据库连接、配置 Spring 事务</p><p>3）配置加载配置文件的读取，开启注解</p><p>4）配置日志文件</p><p>…</p><p>n) 配置完成之后部署 tomcat 调试</p><p>可能你还需要考虑各个版本的兼容性，jar 包冲突的各种可行性。</p><p>那么使用 Spring Boot 之后我们需要开发一个 web 项目需要哪些操作呢？</p><p>1）登录网址 http://start.spring.io/ 选择对应的组件直接下载</p><p>2）导入项目，直接开发</p><p>上面的 N 步和下面的2步形成巨大的反差，这仅仅只是在开发环境搭建的这个方面。</p><p>Spring Boot 使测试变得更简单</p><p>Spring Boot 对测试的支持不可谓不强大，Spring Boot 内置了7种强大的测试框架：</p><p>JUnit： 一个 Java 语言的单元测试框架</p><p>Spring Test &amp; Spring Boot Test：为 Spring Boot 应用提供集成测试和工具支持</p><p>AssertJ：支持流式断言的 Java 测试框架</p><p>Hamcrest：一个匹配器库</p><p>Mockito：一个 java mock 框架</p><p>JSONassert：一个针对 JSON 的断言库</p><p>JsonPath：JSON XPath 库</p><p>我们只需要在项目中引入spring-boot-starter-test依赖包，就可以对数据库、Mock、 Web 等各种情况进行测试。</p><p>Spring Boot 让配置变得更简单</p><p>Spring Boot 的核心思想：约定优于配置，也称作按约定编程，是一种软件设计范式，旨在减少软件开发人员需做决定的数量，获得简单的好处，而又不失灵活性。</p><p>本质是说，开发人员仅需规定应用中不符约定的部分。例如，如果模型中有个名为 User 的类，那么数据库中对应的表就会默认命名为 user。只有在偏离这一约定时，例如将该表命名为”user_info”，才需写有关这个名字的配置。</p><p>Spring Boot 让部署变得更简单</p><p>使用 Spring Boot 开发 Web 项目，让我们不需要关心容器的环境问题，专心写业务代码即可。</p><p>Jenkins 是目前持续构建领域使用最广泛的工具之一，Jenkins 是一个独立的开源自动化服务器，可用于自动化各种任务，如构建，测试和部署软件。Jenkins 可以通过本机系统包 Docker 安装，甚至可以通过安装 Java Runtime Environment 的任何机器独立运行。</p><p>说直白一点 Jenkins 就是专门来负责如何将代码变成可执行的程序包，将它部署到目标服务器中，并对其运营状态（日志）进行监控的软件。自动化、性能、打包、部署、发布、发布结果自动化验证、接口测试、单元测试等等关于我们打包测试部署的方方面面 Jenkins 都可以很友好的支持。</p><p>使用 Jenkins 部署 Spring Boot 项目非常简单，大家想继续了解可以参考我的文章：使用Jenkins部署Spring Boot，只需要前期做一些简单的配置，当我们需要发布项目时只需要点击项目对应的发布按钮，就可以将项目从版本库中拉取、打包、发布到目标服务器中，大大简化了运维后期的部署工作。</p><p>虚拟化技术的发展给我们带来了更多的可能性，我们可以利用容器化技术，将 Spring Boot 项目做成镜像，根据容器集群的策略来实现弹性扩容、动态部署等。所以 Spring Boot + Docker + Jenkins 会将 Spring Boot 项目的部署做得更简单化、智能化。</p><p>Spring Boot 让监控变得更简单</p><p>Spring Boot Actuator 是 Spring Boot 提供的对应用系统监控的集成功能，可以查看应用配置的详细信息，例如自动化配置信息、创建的 Spring beans 以及一些环境属性等。</p><p>Spring Boot Admin （基于 Spring boot actuator）是一个管理和监控 Spring Boot 应用程序的开源软件。每个应用都认为是一个客户端，通过 HTTP 或者使用 Eureka 注册到 admin server 中进行展示，Spring Boot Admin UI 部分使用 AngularJs 将数据展示在前端。</p><p>Spring Boot Admin 是一个针对 spring-boot 的 actuator 接口进行UI美化封装的监控工具。他可以：在列表中浏览所有被监控 spring-boot 项目的基本信息，详细的 Health 信息、内存信息、JVM 信息、垃圾回收信息、各种配置信息（比如数据源、缓存列表和命中率）等，还可以直接修改logger的level。</p><p>使用 Spring Boot Admin 不仅可以监控 Spring Boot 项目，还可以监控 Spring Cloud 项目，因此使用了 Spring Boot 项目之后我们监控 Spring Boot 集群效果如下：</p><p><br></p><p><br></p><p>简单、直观、易用是它的特点，针对一些特殊情况还可以提供报警服务。所以说使用 Spring Boot Actuator 解决了单个 Spring Boot 的监控问题，使用 Spring Boot Admin 就是解决了整个集群监控的问题。</p><p>Spring 、Spring Boot 和 Spring Cloud 的关系</p><p>Spring 最初最核心的两大核心功能 Spring Ioc 和 Spring Aop 成就了 Spring，Spring 在这两大核心的功能上不断的发展，才有了 Spring 事务、Spring Mvc 等一系列伟大的产品，最终成就了 Spring 帝国，到了后期 Spring 几乎可以解决企业开发中的所有问题。</p><p>Spring Boot 是在强大的 Spring 帝国生态基础上面发展而来，发明 Spring Boot 不是为了取代 Spring ,是为了让人们更容易的使用 Spring 。所以说没有 Spring 强大的功能和生态，就不会有后期的 Spring Boot 火热, Spring Boot 使用约定优于配置的理念，重新重构了 Spring 的使用，让 Spring 后续的发展更有生命力。</p><p>Spring Cloud 是一系列框架的有序集合。它利用 Spring Boot 的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等，都可以用 Spring Boot 的开发风格做到一键启动和部署。</p>','spring boot简介','spring boot',0,'http://localhost:9010/picture/2019—01-31 21-46-12.jpg','2019-02-05 03-10-27',2,1,'spring boot简介',2,'Spring Boot',10,NULL),(55,0,'博客链接：<a href=\"https://www.cnblogs.com/dennyzhangdd/p/8028950.html\" target=\"_blank\">https://www.cnblogs.com/dennyzhangdd/p/8028950.html</a>','容器启动','spring boot',0,'http://localhost:9010/picture/2019—01-31 21-46-12.jpg','2019-02-05 03-12-08',2,1,'spring boot容器启动',2,'Spring Boot',10,NULL),(56,0,'<div>redis介绍</div><div>Redis是目前业界使用最广泛的内存数据存储。相比memcached，Redis支持更丰富的数据结构，例如hashes, lists, sets等，同时支持数据持久化。除此之外，Redis还提供一些类数据库的特性，比如事务，HA，主从库。可以说Redis兼具了缓存系统和数据库的一些特性，因此有着丰富的应用场景。本文介绍Redis在Spring Boot中两个典型的应用场景。</div><div>原文即使用链接：<a href=\"https://www.cnblogs.com/ityouknow/p/5748830.html\" target=\"_blank\">https://www.cnblogs.com/ityouknow/p/5748830.html</a></div>','redis','spring boot；redis',0,'http://localhost:9010/picture/2019—01-31 21-46-12.jpg','2019-02-05 03-13-19',2,1,'spring boot之redis',2,'Spring Boot',10,NULL),(57,0,'<div>一、Swagger简介</div><div>　　上一篇文章中我们介绍了Spring Boot对Restful的支持，这篇文章我们继续讨论这个话题，不过，我们这里不再讨论Restful API如何实现，而是讨论Restful API文档的维护问题。</div><div>　　在日常的工作中，我们往往需要给前端（WEB端、IOS、Android）或者第三方提供接口，这个时候我们就需要给他们提供一份详细的API说明文档。但维护一份详细的文档可不是一件简单的事情。首先，编写一份详细的文档本身就是一件很费时费力的事情，另一方面，由于代码和文档是分离的，所以很容易导致文档和代码的不一致。这篇文章我们就来分享一种API文档维护的方式，即通过Swagger来自动生成Restuful API文档。</div><div>　　那什么是Swagger？我们可以直接看下官方的描述：</div><div><br></div><div>THE WORLD\'S MOST POPULAR API TOOLING</div><div>Swagger is the world’s largest framework of API developer tools for the OpenAPI Specification(OAS),&nbsp;</div><div>enabling development across the entire API lifecycle, from design and documentation, to test and deployment.</div><div>　　这段话首先告诉大家Swagger是世界上最流行的API工具，并且Swagger的目的是支撑整个API生命周期的开发，包括设计、文档以及测试和部署。这篇文章中我们会用到Swagger的文档管理和测试功能。</div><div>　　对Swagger的作用有了基本的认识后，我们现在来看看怎么使用。</div><div>原文即实例地址：<a href=\"https://www.cnblogs.com/paddix/p/8204916.html\" target=\"_blank\">https://www.cnblogs.com/paddix/p/8204916.html</a></div>','swagger2','spring boot；swagger2',0,'http://localhost:9010/picture/2019—01-31 21-46-12.jpg','2019-02-05 03-15-09',2,1,'spring boot集成Swagger2',2,'Spring Boot',10,NULL),(58,0,'<div>Spring Boot配置文件详解</div><div>Spring Boot提供了两种常用的配置文件，分别是properties文件和yml文件。他们的作用都是修改Spring Boot自动配置的默认值。相对于properties文件而言，yml文件更年轻，也有很多的坑。可谓成也萧何败也萧何，yml通过空格来确定层级关系，使配置文件结构更清晰，但也会因为微不足道的空格而破坏了层级关系。本章重点介绍yml的语法和从配置文件中取值。还在等什么，赶快来学习吧！</div><div>技术：yaml、properties语法，ConfigurationProperties和Value注解的使用，配置文件占位符的使用</div><div>说明：本章重点介绍yaml的语法和ConfigurationProperties注解的使用，测试代码和完整代码请移步github，喜欢的朋友可以点个star。</div><div>源码：https://github.com/ITDragonBlog/daydayup/tree/master/SpringBoot/spring-boot-yml</div><div>博客链接：<a href=\"https://www.cnblogs.com/itdragon/p/8686554.html\" target=\"_blank\">https://www.cnblogs.com/itdragon/p/8686554.html</a></div>','配置文件详解','spring boot；配置文件',2,'http://localhost:9010/picture/2019—01-31 21-46-12.jpg','2019-02-05 03-18-25',2,1,'spring boot配置文件详解',2,'Spring Boot',10,NULL),(59,0,'<div>spring cloud 入门系列一：初识spring cloud&nbsp;</div><div><br></div><div>最近看到微服务很火，也是未来的趋势，</div><div>所以就去学习下，在dubbo和spring cloud之间我选择了从spring cloud，主要有如下几种原因：</div><div>dubbo主要专注于微服务中的一个环节--服务治理，像服务注册和发现这种还需要zookeeper第三方的中间;但是spring cloud提供了微服务的一站式解决方案,该有的功能都有了。</div><div>spring cloud 社区似乎更加活跃，未来可能成为这个行业的标准。</div><div>自己所在公司的云部门就是用的spring boot/cloud，有先入为主的赶脚吧。</div><div>&nbsp;</div><div>好，接下来我们来认识下spring cloud.</div><div>一、什么是spring cloud？</div><div>它的中文官网这样说：</div><div>微服务架构集大成者，云计算最佳业务实践。</div><div>百度百科这样说的：</div><div>Spring Cloud是一系列框架的有序集合。它利用Spring Boot的开发便利性巧妙地简化了分布式系统基础设施的开发，</div><div>如服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等，都可以用Spring Boot的开发风格做到一键启动和部署。</div><div>Spring Cloud并没有重复制造轮子，它只是将目前各家公司开发的比较成熟、经得起实际考验的服务框架组合起来，</div><div>通过Spring Boot风格进行再封装屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易懂、易部署和易维护的分布式系统开发工具包。</div><div><br></div><div>二、学习资源推荐</div><div>1、spring cloud中文网：<a href=\"https://springcloud.cc/\" target=\"_blank\">https://springcloud.cc/</a></div><div>2、spring cloud中国社区：<a href=\"http://docs.springcloud.cn/\" target=\"_blank\">http://docs.springcloud.cn/</a></div><div>3、纯洁的微笑：<a href=\"http://www.ityouknow.com/\" target=\"_blank\">http://www.ityouknow.com/</a></div><div>4、程序员DD：<a href=\"http://blog.didispace.com/\" target=\"_blank\">http://blog.didispace.com/</a></div><div><br></div>','spring cloud简介','spring cloud',1,'http://localhost:9010/picture/2019—01-31 21-46-12.jpg','2019-02-05 03-23-54',2,1,'spring cloud之简介',2,'Spring Cloud',11,NULL),(60,0,'<div>Java 微服务框架选型（Dubbo 和 Spring Cloud？）&nbsp;</div><div><br></div><div>微服务（Microservices）是一种架构风格，一个大型复杂软件应用由一个或多个微服务组成。系统中的各个微服务可被独立部署，各个微服务之间是松耦合的。每个微服务仅关注于完成一件任务并很好地完成该任务。在所有情况下，每个任务代表着一个小的业务能力。</div><div>以往我们开发应用程序都是单体型（可以看作是一个怪兽?），虽然开发和部署比较方便，但后期随着业务的不断增加，开发迭代和性能瓶颈等问题，将会困扰开发团队，微服务就是解决此问题的有效手段，市面上有很多的微服务框架，比如最著名的两个 Dubbo 和 Spring Cloud，我们该如何选择呢？</div><div>公司近期打算向 Java 微服务技术转型（一步一步实现，会考虑兼容 .NET/.NET Core），以下是我整理的相关内容，如果你有更好的建议和意见，欢迎探讨～～～</div><div>关于 RPC/gRPC/HTTP/REST</div><div>因为服务调用方式是 Dubbo 和 Spring Cloud 重要不同点，了解 RPC/gRPC/HTTP/REST 相关概念，有助于对比 Dubbo 和 Spring Cloud。</div><div>RPC 是远端过程调用，其调用协议通常包含传输协议和编码协议。</div><div>HTTP 严格来说跟 RPC 不是一个层级的概念，HTTP 本身也可以作为 RPC 的传输层协议。</div><div>传输协议包含: 如著名的 gRPC 使用的 HTTP 2.0 协议，也有如 Dubbo 一类的自定义报文的 TCP 协议。编码协议包含: 如基于文本编码的 XML Json，也有二进制编码的 ProtoBuf Binpack 等。</div><div>所谓的效率优势是针对 HTTP 1.1 协议来讲的，HTTP 2.0 协议已经优化编码效率问题，像 gRPC 这种 RPC 库使用的就是 HTTP 2.0 协议。</div><div>在跨语言调用的时候，REST 风格直接把 HTTP 作为应用协议（直接和服务打交道），不同语言之间调用比较方便。</div><div>而 RPC 可以把 HTTP 作为一种传输协议（比如 gRPC 使用 HTTP 2.0 协议传输），本身还会封装一层 RPC 框架的应用层协议，不同语言之间调用需要依赖 RPC 协议（需要跨语言 RPC 库实现，比如 Thrift）。</div><div>问题：为什么 Dubbo 比 Spring Cloud 性能要高一些？</div><div>回答：因为 Dubbo 采用单一长连接和 NIO 异步通讯（保持连接/轮询处理），使用自定义报文的 TCP 协议，并且序列化使用定制 Hessian2 框架，适合于小数据量大并发的服务调用，以及服务消费者机器数远大于服务提供者机器数的情况，但不适用于传输大数据的服务调用。而 Spring Cloud 直接使用 HTTP 协议（但也不是强绑定，也可以使用 RPC 库，或者采用 HTTP 2.0 + 长链接方式（Fegin 可以灵活设置））。</div><div>另外，Martin Fowler 的 MicroServices 一文，其定义的服务间通信是 HTTP 协议的 REST API。</div><div>详细博客地址：<a href=\"https://www.cnblogs.com/xishuai/p/dubbo-and-spring-cloud.html\" target=\"_blank\">https://www.cnblogs.com/xishuai/p/dubbo-and-spring-cloud.html</a></div>','微服务框架','spring cloud；微服务框架',0,'http://localhost:9010/picture/2019—01-31 21-46-12.jpg','2019-02-05 03-25-07',2,1,'spring cloud之微服务框架',2,'Spring Cloud',11,NULL),(61,0,'<div>Spring cloud实现服务注册及发现&nbsp;</div><div><br></div><div>　　服务注册与发现对于微服务系统来说非常重要。有了服务发现与注册，你就不需要整天改服务调用的配置文件了，你只需要使用服务的标识符，就可以访问到服务。</div><div>　　本文属于《7天学会spring cloud系列》之四，关注服务注册与发现，本文涉及到的项目：</div><div>开源项目：http://git.oschina.net/zhou666/spring-cloud-7simple</div><div>cloud-eureka-server：eureka注册服务器</div><div>cloud-simple-service：一个使用mybatis的数据库应用，服务端</div><div>　　服务注册管理器原理如下图所示：</div><div>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</div><div>　　所有的服务端及访问服务的客户端都需要连接到注册管理器（eureka服务器）。服务在启动时会自动注册自己到eureka服务器，每一个服务都有一个名字，这个名字会被注册到eureka服务器。使用服务的一方只需要使用该名字加上方法名就可以调用到服务。</div><div>　　Spring cloud的服务注册及发现，不仅仅只有eureka，还支持Zookeeper和Consul。默认情况下是eureka，spring 封装了eureka，使其非常简单易用，只需要比传统应用增加一行代码就可以使用了，这一行代码就是一个注解。我们按以下步骤实现服务注册和发现功能。</div><div>详细链接：<a href=\"Spring cloud实现服务注册及发现   　　服务注册与发现对于微服务系统来说非常重要。有了服务发现与注册，你就不需要整天改服务调用的配置文件了，你只需要使用服务的标识符，就可以访问到服务。 　　本文属于《7天学会spring cloud系列》之四，关注服务注册与发现，本文涉及到的项目： 开源项目：http://git.oschina.net/zhou666/spring-cloud-7simple cloud-eureka-server：eureka注册服务器 cloud-simple-service：一个使用mybatis的数据库应用，服务端 　　服务注册管理器原理如下图所示：          　　所有的服务端及访问服务的客户端都需要连接到注册管理器（eureka服务器）。服务在启动时会自动注册自己到eureka服务器，每一个服务都有一个名字，这个名字会被注册到eureka服务器。使用服务的一方只需要使用该名字加上方法名就可以调用到服务。 　　Spring cloud的服务注册及发现，不仅仅只有eureka，还支持Zookeeper和Consul。默认情况下是eureka，spring 封装了eureka，使其非常简单易用，只需要比传统应用增加一行代码就可以使用了，这一行代码就是一个注解。我们按以下步骤实现服务注册和发现功能。\" target=\"_blank\">Spring cloud实现服务注册及发现   　　服务注册与发现对于微服务系统来说非常重要。有了服务发现与注册，你就不需要整天改服务调用的配置文件了，你只需要使用服务的标识符，就可以访问到服务。 　　本文属于《7天学会spring cloud系列》之四，关注服务注册与发现，本文涉及到的项目： 开源项目：http://git.oschina.net/zhou666/spring-cloud-7simple cloud-eureka-server：eureka注册服务器 cloud-simple-service：一个使用mybatis的数据库应用，服务端 　　服务注册管理器原理如下图所示：          　　所有的服务端及访问服务的客户端都需要连接到注册管理器（eureka服务器）。服务在启动时会自动注册自己到eureka服务器，每一个服务都有一个名字，这个名字会被注册到eureka服务器。使用服务的一方只需要使用该名字加上方法名就可以调用到服务。 　　Spring cloud的服务注册及发现，不仅仅只有eureka，还支持Zookeeper和Consul。默认情况下是eureka，spring 封装了eureka，使其非常简单易用，只需要比传统应用增加一行代码就可以使用了，这一行代码就是一个注解。我们按以下步骤实现服务注册和发现功能。</a></div>','微服务的注册发现','spring cloud；微服务',0,'http://localhost:9010/picture/2019—01-31 21-46-12.jpg','2019-02-05 03-27-33',2,1,'spring cloud之微服务的注册和发现',2,'Spring Cloud',11,NULL),(62,0,'博客链接：<a href=\"https://www.cnblogs.com/heqiyoujing/p/9451210.html\" target=\"_blank\">https://www.cnblogs.com/heqiyoujing/p/9451210.html</a>','学习相关资料','spring cloud；学习资料',0,'http://localhost:9010/picture/2019—01-31 21-46-12.jpg','2019-02-05 03-30-53',2,1,'spring cloud之学习的相关资料',2,'Spring Cloud',11,NULL),(63,0,'<div>Spring Cloud微服务分布式云架构简介&nbsp;</div><div><br></div><div>Spring Cloud是一系列框架的有序集合。利用Spring Boot的开发模式简化了分布式系统基础设施的开发，如服务发现、注册、配置中心、消息总线、负载均衡、断路器、数据监控等（这里只简单的列了一部分），都可以用Spring Boot的开发风格做到一键启动和部署。Spring Cloud将目前比较成熟、经得起实际考验的服务框架组合起来，通过Spring Boot风格进行再封装，屏蔽掉了复杂的配置和实现原理，最终整合出一套简单易懂、易部署和易维护的分布式系统架构平台。</div><div>&nbsp;</div><div>Spring Cloud组成</div><div>Spring Cloud的子项目，大致可分成两类：</div><div>一类是对现有成熟框架Spring Boot的封装和抽象，也是数量最多的项目；</div><div>第二类是开发了一部分分布式系统的基础设施的实现，如Spring Cloud Stream就是kafka, ActiveMQ这样的角色。开发人员进行微服务的实践，第一类子项目就已经足够使用，如：</div><div>Spring Cloud Netflix</div><div>　　是对Netflix开发的一套分布式服务框架的封装，包括服务的发现和注册，负载均衡、断路器、REST客户端、请求路由等。</div><div>Spring Cloud Config</div><div>　　将配置信息中央化保存, 配置Spring Cloud Bus可以实现动态修改配置文件。</div><div>Spring Cloud Bus</div><div>　　分布式消息队列，是对Kafka, MQ的封装。</div><div>Spring Cloud Security</div><div>　　对Spring Security的封装，并能配合Netflix使用。</div><div>Spring Cloud Zookeeper</div><div>　　对Zookeeper的封装，使之能配置其它Spring Cloud的子项目使用。</div><div>Spring Cloud Eureka</div><div>&nbsp; &nbsp; &nbsp; Spring Cloud Eureka 是 Spring Cloud Netflix 微服务套件中的一部分，它基于Netflix Eureka 做了二次分装，主要负责完成微服务架构中的服务治理功能。</div><div>&nbsp;</div><div>Spring Cloud未来</div><div>Spring Cloud为未来互联网企业提供分布式基础设施解决方案。同时，随着近几年微服务架构和Docker容器概念的火爆，也会让Spring Cloud在未来越来越“云”化的软件开发风格中立有一席之地，尤其是在目前五花八门的分布式解决方案中提供了标准化的、全站式的技术方案，有效推进服务端软件系统技术水平提升。</div><div>从现在开始，我这边会将近期研发的spring cloud微服务云架构的搭建过程和精髓记录下来，帮助更多有兴趣研发spring cloud框架的朋友，大家来一起探讨spring cloud架构的搭建过程及如何运用于企业项目。 源码来源：<a href=\"http://minglisoft.cn/honghu/technology.html\" target=\"_blank\">http://minglisoft.cn/honghu/technology.html</a></div>','微服务分布式云架构','spring cloud；微服务',3,'http://localhost:9010/picture/2019—01-31 21-46-12.jpg','2019-02-05 03-32-45',2,1,'spring cloud之微服务分布式云架构简介',2,'Spring Cloud',11,NULL),(64,0,'<div>spring cloud bus原理总结&nbsp;</div><div><br></div><div>1、spring cloud bus</div><div>　　spring cloud是按照spring的配置对一系列微服务框架的集成，spring cloud bus是其中一个微服务框架，用于实现微服务之间的通信。</div><div>　　spring cloud bus整合 java的事件处理机制和消息中间件消息的发送和接受，主要由发送端、接收端和事件组成。针对不同的业务需求，可以设置不同的事件，发送端发送事件，接收端接受相应的事件，并进行相应的处理。</div><div>详细博客链接：<a href=\"https://www.cnblogs.com/songxh-scse/p/7833963.html\" target=\"_blank\">https://www.cnblogs.com/songxh-scse/p/7833963.html</a></div>','bus','spring cloud；bus',1,'http://localhost:9010/picture/2019—01-31 21-46-12.jpg','2019-02-05 03-34-39',2,1,'spring cloud之bus',2,'Spring Cloud',11,NULL),(88,0,'<p>dcfdsxfac</p>','发按时发','asfsd a',0,'http://localhost:9010/picture/2019—01-31 21-45-53.jpg','2019-02-16 15-57-44',1,1,'sdfda',1,'javaSE ',8,NULL),(89,0,'<p>平时使用的持久化框架就是jpa，年前就看了一部分，对用法和原理有了一点点的理解，对做项目真的还是挺有帮助的，这里有介绍了我看过大部分的jpa的用法。好久都没有更博客了，快放假的时候就开始放纵自己了，没有看点东西，也没有锻炼，外加新年一共胖了五斤，最近有时间在的锻炼减肥，自从15年瘦下来之后，16年17年我的体重几乎没有什么改进，而且每次跑步的公里数也就5km左右，太惯着自己，最近开始10km、15km了，当然常规还是10km，不能不进步呀。</p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p>ORM</p><p>jpa基本介绍</p><p>jpa的功能</p><p>（1）JPA的CRUD操作</p><p>（2）通过jpql语句进行查询</p><p>（3）动词findBy查询</p><p>（4）动态分页查询</p><p>（5）原生查询</p><p>（5）一对一、多对多查询</p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p>ORM</p><p><br></p><p>熟悉框架之前必须要知道ORM是什么，因为jpa就是一个ORM框架。&nbsp;</p><p>&nbsp;- （1）定义：ORM英文全写Object relational mapping，也就是英文的表面意思对象关系映射，关系型数据库和对象之间的一一映射，如果有个用户表user【id、userName、pwd】、如果建立对象之间的一一映射，那么我们也需要建相应的类User.class，User类的属性和数据库要一一对应，User类存在的属性，必须要在数据库表内找到相对应的属性相对应，但是数据库表中存在的属性，在类中不一定要存在，如果不对该字段进行任何的操作，可以在类中不定义对应的属性。&nbsp;</p><p>&nbsp;- （2）优势：程序中做的大部分的工作就是对输入数据做一些业务逻辑操作，目的是完成对数据的CRUD操作，最终持久化操。对数据库模型（ORM对象）的操作归根结底也就是对数据库的操作，先对ORM对象进行业务逻辑操作，然后持久化，最终完成对数据的操作。</p><p><br></p><p><br></p><p><br></p><p>jpa基本介绍</p><p><br></p><p><br></p><p>（1）与hibernate的关系：jpa是标准，实际上，jpa只是定义了接口，实现都是hibernate在做。</p><p>（2）jpa存在的目的：让spring实现持久化操作，spring本来对第三方框架的整合上的特别的好。</p><p>（3）提供的功能：一般的框架都有一个对象操作DB（数据库），hibernate的session、mybatis的sqlSession，jpa的entityManager。这几个框架我都用过，仅仅一点点，也可以说说不会，当初hibernate我用的时候配置还是比较繁琐的，但是我的印象中它好像不用写sql语句。mybatis，有一个和数据相对应的mapper.xml文件，和数据库一一对应，可以写sql语句，mapper中写的sql可以进行各种if判断的，感觉也很强大的。一般的ORM框架只能提供CRUD操作，但是jpa可以提供逻辑处理的。刚看这里的时候我还不太理解这个地方是什么意思，提议的去查了一下业务逻辑的定义。对于不同的功能有这不同的实现，不同的实现，实现这些功能的核心代码就叫做业务逻辑，如果我们的功能是实现求两个数的和，那么我们程序中的代码实现也就是业务逻辑处理。</p><p>（4）dao：data access object数据库访问对象，跟respository是一样的。</p><p><br></p><p><br></p><p><br></p><p><br></p><p>jpa的功能</p><p><br></p><p><br></p><p>（1）前言：&nbsp;</p><p>1）具体实现功能包括几种：直接实现JpaRepository的接口，可以通过jpa提供的方法对数据库进行操作，jap自定义接口中的@Query自定义jpql语句查询、findBy动词自定义查询语句、动态分页查询、原生sql查询。&nbsp;</p><p>&nbsp;</p><p>2）在我定义的TeacherRepository接口中，实现了接口JpaSpecificationExecutor和&nbsp;</p><p>JpaRepository。JpaRepository定义了一组标准的接口，CrudRepository继承了Repository接口，定义了一组CRUD的操作方法，也就是说只要我们的类实现JpaRepository接口就行了对模型对象进行CRUD操作。JpaSpecificationExecutor接口提供了一组基于标准JPA Criteria查询相关的方法，也就是分页动态查询相关的操作。&nbsp;</p><p>3）在使用jpa的时候真的”针对接口编程“了，除了定义方法外没有做任何的实现，有的时候甚至在xxxRespository类中没有定义任何的方法，那就说明jpa提供的方法足以满足程序功能的需求了，正常接口应该需要实现类的呀，如果定义了实现类实现了&nbsp;</p><p>JpaSpecificationExecutor和JpaRepository接口，那么实现类中会有几十个实现方法，实现几十个方法还怎么玩。其实jpa给我们提供的具体的实现方法不需要我们做其他的操作。</p><p><br></p><p><br></p><p><br></p><p><br></p><p>public class SimpleJpaRepository&lt;T, ID extends Serializable&gt;&nbsp;</p><p>implements JpaRepository&lt;T, ID&gt;,JpaSpecificationExecutor&lt;T&gt;12</p><p><br></p><p>当然也可以定义实现类的，但是只需要放在 xxxRespository一个文件下即可，我写的中impl形式的类都用来写自定义的sql，下面有介绍。jpa给我们提供了SimpleJpaRepository实现类，所以只需要我们定义接口就可以了。</p><p><br></p><p><br></p><p><br></p><p>（1）JPA的CRUD操作</p><p><br></p><p><br></p><p><br></p><p>&nbsp; &nbsp; &nbsp;&lt;S extends T&gt; S save(S var1);</p><p>&nbsp; &nbsp; &nbsp;&lt;S extends T&gt; Iterable&lt;S&gt; save(Iterable&lt;S&gt; var1);</p><p>&nbsp; &nbsp; &nbsp; T findOne(ID var1);</p><p>&nbsp; &nbsp; &nbsp;long count();</p><p>&nbsp; &nbsp; &nbsp;void delete(ID var1);</p><p>&nbsp; &nbsp; &nbsp;void delete(T var1);</p><p>&nbsp; &nbsp; &nbsp;void delete(Iterable&lt;? extends T&gt; var1);</p><p>&nbsp; &nbsp; &nbsp;void deleteAll();12345678</p><p><br></p><p><br></p><p><br></p><p>&nbsp; &nbsp;@Override</p><p>&nbsp; &nbsp; public UserEntity save(UserEntity user) {</p><p>&nbsp; &nbsp; &nbsp; &nbsp; logger.info(\"user:[{}]\", JSON.toJSON(user));</p><p>&nbsp; &nbsp; &nbsp; &nbsp; testRepository.save(user);</p><p>&nbsp; &nbsp; &nbsp; &nbsp; return user;</p><p>&nbsp; &nbsp; }123456</p><p><br></p><p>直接通过注入的xxxRespository.save即可保存，如果这个user对象存在会替换DB中的数据。delele时，如果如数要删除实体或者该条数据的唯一标识符即可。</p><p><br></p><p><br></p><p><br></p><p>（2）通过jpql语句进行查询</p><p><br></p><p><br></p><p><br></p><p>&nbsp; @Query(value = \"from StudentEntity s where s.s_name =?1\")</p><p>&nbsp; &nbsp; StudentEntity queryByName(String name);12</p><p><br></p><p>在定义的xxxRepository类型直接，定义方法即可，上面接口中定义的方法就是根据学生的姓名查找学生实体。</p><p><br></p><p><br></p><p><br></p><p>（3）动词findBy查询</p><p><br></p><p><br></p><p><br></p><p>UserEntity findByNameAndPassword(String name,String password);1</p><p><br></p><p>根据用户和密码查询用户的信息，findBy+各种条件，如果有兴趣了解详细的命名规则参考博客 http://blog.csdn.net/sbin456/article/details/53304148。</p><p><br></p><p><br></p><p><br></p><p>（4）动态分页查询</p><p><br></p><p><br></p><p><br></p><p>&nbsp;@Override</p><p>&nbsp; &nbsp; public List&lt;ScEntity&gt; getScDynamicQuery(int pageSize, int size) {</p><p>&nbsp; &nbsp; &nbsp; &nbsp; Specification&lt;ScEntity&gt; specification = specificationConfig.where();</p><p>&nbsp; &nbsp; &nbsp; &nbsp; Sort sort = new Sort(Sort.Direction.ASC, \"id\");</p><p>&nbsp; &nbsp; &nbsp; &nbsp; Pageable pageable = new PageRequest(pageSize,size, sort);</p><p>&nbsp; &nbsp; &nbsp; &nbsp; Page&lt;ScEntity&gt; page = scRepository.findAll(specification,pageable);</p><p>&nbsp; &nbsp; &nbsp; &nbsp; List&lt;ScEntity&gt; list = page.getContent();</p><p>&nbsp; &nbsp; &nbsp; &nbsp; if(list.size()&gt;0){</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for(ScEntity entity : list){</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; System.out.println(entity.getId());</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</p><p>&nbsp; &nbsp; &nbsp; &nbsp; }</p><p>&nbsp; &nbsp; &nbsp; &nbsp; return page.getContent();</p><p>&nbsp; &nbsp; }</p><p>//where条件代码 定义在SpecificationConfig类中</p><p>&nbsp;public Specification&lt;T&gt; where(){</p><p>&nbsp; &nbsp; &nbsp; &nbsp; return new Specification() {</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; @Override</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; public Predicate toPredicate(Root root, CriteriaQuery query, CriteriaBuilder cb) {</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /**</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* 1 Root ORM对象和数据表对应，</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* 2 CriteriaBuilder 相当于SQL的where条件</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* 3 CriteriaQuery是一个顶层的查询，它包含查询的各个部分select 、from、where、group by、order by</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List&lt;Predicate&gt; predicates = new ArrayList&lt;Predicate&gt;();</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return query.where(predicates.toArray(new Predicate[predicates.size()])).getRestriction();</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</p><p>&nbsp; &nbsp; &nbsp; &nbsp; };</p><p>&nbsp; &nbsp; }1234567891011121314151617181920212223242526272829</p><p><br></p><p>1）Specification规范类，也就查询所需要的条件，归根揭底我们提供能的条件，组装了jpa能够识别的sql条件。SpecificationConfig类是一个泛型类，编译时决定Specification的类型，这样做的好处是，需要类似Specification条件的类可以进行复用。上面代码返回的Specification类型就是ScEntity的。&nbsp;</p><p>&nbsp; 2）scRepository.findAll(specification,pageable)中的findAll就是JpaSpecificationExecutor接口中提供的方法，Pageable类是分页类，它提供了查询第几页，以那个属性如何排序展示结果。findAll方法的参数中Specification类型是动态变化的，也就是根据Specification的类型的变化，findAll展现出不同类型的结果，它其实是一个策略模式，我的理解策略模式跟多态性有相近的意思，运行时动态的根据对象的类型展现不同的结果。&nbsp;</p><p>&nbsp; 3）下面说说这个Specification类：</p><p><br></p><p><br></p><p><br></p><p>public interface Specification&lt;T&gt; {</p><p>Predicate toPredicate</p><p>&nbsp; &nbsp; (Root&lt;T&gt; root, CriteriaQuery&lt;?&gt; query, CriteriaBuilder cb);123</p><p><br></p><p>在我的SpecificationConfig类型，并没有实现Specification这个接口，但是我需要组装查询条件，需要返回一个Specification类型的类，接口不能初始化，所以在这里通过匿名内部类来实现这个接口。&nbsp;</p><p>定义查询条件：这个条件是我编的，相当于&nbsp;&nbsp;</p><p>where uuid like %uuid% and accNo =”acctNo“。</p><p><br></p><p><br></p><p><br></p><p>&nbsp;List&lt;Predicate&gt; list&nbsp; = new ArrayList&lt;&gt;();</p><p>&nbsp;String uuid = \"\";</p><p>&nbsp;list.add(cb.like(root.&lt;String&gt;get(\"uuid\"), \"%\"+ uuid +\"%\" ));</p><p>&nbsp;String acctNo= \"\";</p><p>&nbsp;ist.add(cb.equal(root.get(\"acctNo\"), acctNo));</p><p>&nbsp;return query.where(list.toArray(</p><p>&nbsp;new Predicate[list.size()])).getRestriction();1234567</p><p><br></p><p>Root类相当于ORM对应的模型类，root是从模型中获取模型属性值的。&nbsp;</p><p>CriteriaBuilder：创建查询条件的。&nbsp;</p><p>Query：相当于一个顶层查询类，在这类相当于构建where条件的。</p><p><br></p><p><br></p><p><br></p><p>（5）原生查询</p><p><br></p><p>如果涉及到的字段比较多，而且是一些报表统计类的查询表的话，通过无论通过jpa动态查询还是通过其他的查询可能都是比较繁琐的，jpa也是支持原生sql查询的，下面提供两种查询方式，但是getResultList()返回结果有三种形式：</p><p><br></p><p><br></p><p><br></p><p>&nbsp; public List&lt;ScEntity&gt; findBySId(Long sId){</p><p><br></p><p>&nbsp; &nbsp; &nbsp; &nbsp; String sql = \"select * from sc where s_id = \'\" + sId + \"\'\";</p><p>&nbsp; &nbsp; &nbsp; &nbsp; Query query = entityManager.createNativeQuery(sql);</p><p>&nbsp; &nbsp; &nbsp; &nbsp; List&lt;ScEntity&gt; list = query.getResultList();</p><p><br></p><p>&nbsp; &nbsp; &nbsp; &nbsp; //List listMap = query.getResultList();</p><p><br></p><p>&nbsp; &nbsp; &nbsp; &nbsp; String sqlStr = \"select s from ScEntity s where s.s_id = \'\" + sId + \"\'\";</p><p>&nbsp; &nbsp; &nbsp; &nbsp; query = entityManager.createQuery(sqlStr) ;</p><p>&nbsp; &nbsp; &nbsp; &nbsp; List&lt;ScEntity&gt; listStr = query.getResultList();</p><p>&nbsp; &nbsp; &nbsp; &nbsp; return list;</p><p>&nbsp; &nbsp; }12345678910111213</p><p><br></p><p>1）createNativeQuery：参数sql 是根据数据表的名字而构造的查询sql语句。&nbsp;</p><p>&nbsp; 2）createQuery：参数是以对象模型而构造的查询语句。&nbsp;</p><p>&nbsp; 3)&nbsp; &nbsp;看我注释掉的那句话，如果你是做用户报表类的查询的话，查询结果不可能是一个表内的，如果是一个表内的话你可能也只是想查询出几个属性值，那么我们的list返回结果就不是个实体类型的，而需要我们去解析，其实返回的是一个键值对，下面展示一下我做过的报表查询类的代码与解析。</p><p><br></p><p><br></p><p><br></p><p>Query query = entityManager.createNativeQuery(columsSql);</p><p>query.unwrap(SQLQuery.class).setResultTransformer(Transformers.ALIAS_TO_ENTITY_MAP);</p><p>List list = query.getResultList();</p><p>//解析</p><p>&nbsp;Map&lt;String,String&gt; map = new HashMap&lt;&gt;();</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if(list.size() &gt; 0){</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for(Object o :list){</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Map&lt;String,String&gt; temp =(HashMap)o;</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (Map.Entry entry : temp.entrySet()){</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if(entry.getValue() == null){</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; map.put(entry.getKey().toString(),BigDecimal.ZERO.toString());</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }else{</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; map.put(entry.getKey().toString(),entry.getValue().toString());</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }1234567891011121314151617</p><p><br></p><p>所有的查询结果都在这个map中展示。</p><p><br></p><p><br></p><p><br></p><p>（5）一对一、多对多查询</p><p><br></p><p>关联查询分为两种：一种是在动态分页中构建的，另一个是在模型对象中构建的。&nbsp;</p><p>&nbsp; 1）动态分页中构建的查询关系我没有用过，所以我就不介绍了，在我参考的博客里面有。&nbsp;</p><p>&nbsp; 2）另一个是在对象模型中构建的对象之间的关系，这个我随便介绍一个吧，在这之前简单的介绍一下什么是一对多，多对一，多对多，一对一的关系。一对一：一夫一妻。一对多：古代的皇帝和妃子。多对一：多个妃子都应一个皇帝。多对多：不光皇帝有多个妃子呀，王爷也有呀，两个以上的一对多关系就是多对多的关系。</p><p><br></p><p><br></p><p><br></p><p>&nbsp;/**</p><p>&nbsp; &nbsp; &nbsp;* 学生跟成绩是一对多的关系，一个学生有多门成绩</p><p>&nbsp; &nbsp; &nbsp;*/</p><p>&nbsp; &nbsp; @OneToMany(cascade = CascadeType.PERSIST,fetch = FetchType.EAGER)</p><p>&nbsp; &nbsp; @JoinColumn(name=\"s_id\", referencedColumnName=\"s_id\",</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; insertable = false, updatable = false)</p><p>&nbsp; &nbsp; private List&lt;ScEntity&gt; scEntities;</p><p><br></p><p>&nbsp; &nbsp; /**</p><p>&nbsp; &nbsp; &nbsp;* 一个学生对应多个老师</p><p>&nbsp; &nbsp; &nbsp;*/</p><p>&nbsp; &nbsp; @OneToMany(cascade = CascadeType.REMOVE,fetch = FetchType.LAZY)</p><p>&nbsp; &nbsp; @JoinColumn(name=\"s_id\", referencedColumnName=\"s_id\",</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; insertable = false, updatable = false)</p><p>&nbsp; &nbsp; private List&lt;TeacherEntity&gt; thEntity;123456789101112131415</p><p><br></p><p>通过OneToMany注解标注模型对象之间的关系，通过JoinColumn来指出对象之间通过什么关联，顺便说一下级联：级联就是相关联DB之间的同事操作，CascadeType.REMOVE只的是，如果删除当前的实体，那么跟这个实体相关的数据也会被删除，CascadeType还有很多的操作，可以自己搜一下。fetch指的是关联类的加载方式，如果在一个模型中只有一个关联关系，那么它是懒加载还是立即加载都可以，但是如果存在多个关联关系，例如上面代码中，EAGER加载机制只能立即加载一个类到内存中，其他的类均为LAZY类型的加载方式。否则会报错。</p><p>---------------------&nbsp;</p><p>作者：jtracydy&nbsp;</p><p>来源：CSDN&nbsp;</p><p>原文：https://blog.csdn.net/jtracydy/article/details/79514281&nbsp;</p><p>版权声明：本文为博主原创文章，转载请附上博文链接！</p>','spring之jpa','spring；jpa',4,'http://localhost:9010/picture/2019—01-31 21-47-26.jpg','2019-02-16 16-24-53',1,1,'Spring Jpa基础',1,'Spring',12,NULL);
/*!40000 ALTER TABLE `blog` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `blog_type`
--

DROP TABLE IF EXISTS `blog_type`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `blog_type` (
  `type_id` bigint(20) NOT NULL AUTO_INCREMENT,
  `create_time` varchar(255) DEFAULT NULL,
  `type` varchar(255) DEFAULT NULL,
  `type_num` bigint(20) NOT NULL,
  PRIMARY KEY (`type_id`)
) ENGINE=InnoDB AUTO_INCREMENT=13 DEFAULT CHARSET=utf8mb4;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `blog_type`
--

LOCK TABLES `blog_type` WRITE;
/*!40000 ALTER TABLE `blog_type` DISABLE KEYS */;
INSERT INTO `blog_type` VALUES (8,'2019-01-31 22-30-38','javaSE ',7),(9,'2019-01-31 22-30-49','MySQL',8),(10,'2019-02-01 21-52-39','Spring Boot',6),(11,'2019-02-01 21-57-16','Spring Cloud',6),(12,'2019-02-01 22-00-52','Spring',7);
/*!40000 ALTER TABLE `blog_type` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `comment`
--

DROP TABLE IF EXISTS `comment`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `comment` (
  `comment_id` bigint(20) NOT NULL AUTO_INCREMENT,
  `comment_content` varchar(255) DEFAULT NULL,
  `user_id` bigint(20) NOT NULL,
  `blog_id` bigint(20) DEFAULT NULL,
  PRIMARY KEY (`comment_id`),
  KEY `FKkap39f76wn135k7ru564fbjb7` (`blog_id`),
  CONSTRAINT `FKkap39f76wn135k7ru564fbjb7` FOREIGN KEY (`blog_id`) REFERENCES `blog` (`blog_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `comment`
--

LOCK TABLES `comment` WRITE;
/*!40000 ALTER TABLE `comment` DISABLE KEYS */;
/*!40000 ALTER TABLE `comment` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `picture`
--

DROP TABLE IF EXISTS `picture`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `picture` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `path` varchar(255) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=34 DEFAULT CHARSET=utf8mb4;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `picture`
--

LOCK TABLES `picture` WRITE;
/*!40000 ALTER TABLE `picture` DISABLE KEYS */;
INSERT INTO `picture` VALUES (1,'/picture/2019—01-31 21-44-50.jpg'),(2,'/picture/2019—01-31 21-45-11.jpg'),(4,'/picture/2019—01-31 21-45-53.jpg'),(5,'/picture/2019—01-31 21-46-03.jpg'),(6,'/picture/2019—01-31 21-46-12.jpg'),(7,'/picture/2019—01-31 21-46-24.jpg'),(8,'/picture/2019—01-31 21-46-34.jpg'),(9,'/picture/2019—01-31 21-46-43.jpg'),(10,'/picture/2019—01-31 21-46-51.jpg'),(11,'/picture/2019—01-31 21-46-59.jpg'),(12,'/picture/2019—01-31 21-47-15.jpg'),(13,'/picture/2019—01-31 21-47-26.jpg'),(14,'/picture/2019—01-31 21-47-41.jpg'),(15,'/picture/2019—01-31 21-47-53.jpg'),(16,'/picture/2019—01-31 21-48-03.jpg'),(17,'/picture/2019—01-31 21-48-13.jpg'),(18,'/picture/2019—01-31 21-48-26.jpg'),(19,'/picture/2019—01-31 21-48-37.jpg'),(20,'/picture/2019—01-31 21-48-50.jpg'),(21,'/picture/2019—01-31 21-49-00.jpg'),(22,'/picture/2019—01-31 21-49-22.jpg'),(23,'/picture/2019—01-31 21-49-41.jpg'),(24,'/picture/2019—01-31 21-49-51.jpg'),(25,'/picture/2019—01-31 21-50-05.jpg'),(26,'/picture/2019—01-31 21-50-15.jpg'),(27,'/picture/2019—01-31 21-50-31.jpg'),(28,'/picture/2019—01-31 21-50-57.jpg'),(29,'/picture/2019—01-31 21-51-10.jpg'),(30,'/picture/2019—01-31 21-51-22.jpg'),(31,'/picture/2019—01-31 21-51-37.jpg'),(32,'/picture/2019—01-31 21-51-58.jpg'),(33,'/picture/2019—01-31 21-52-09.jpg');
/*!40000 ALTER TABLE `picture` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `resource`
--

DROP TABLE IF EXISTS `resource`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `resource` (
  `resource_id` bigint(20) NOT NULL AUTO_INCREMENT,
  `content` varchar(255) DEFAULT NULL,
  `name` varchar(255) DEFAULT NULL,
  `password` varchar(255) DEFAULT NULL,
  `published_time` varchar(255) DEFAULT NULL,
  `src` varchar(255) DEFAULT NULL,
  `status` int(11) NOT NULL,
  PRIMARY KEY (`resource_id`)
) ENGINE=InnoDB AUTO_INCREMENT=45 DEFAULT CHARSET=utf8mb4;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `resource`
--

LOCK TABLES `resource` WRITE;
/*!40000 ALTER TABLE `resource` DISABLE KEYS */;
INSERT INTO `resource` VALUES (24,'bootstrap教学视频','bootstrap','uos7','2019-01-31 21-00-05','https://pan.baidu.com/s/16ZtVq3pfKQbNDqZ0-QPUnw',1),(25,'redis教学视频','redis','qlhf','2019-01-31 21-03-07','https://pan.baidu.com/s/1W3N5leimyl5R8z-p0CWeDQ',1),(26,'java教学视频','java','ru03','2019-01-31 21-04-49','https://pan.baidu.com/s/1YxPCmFZdLhWWjvGlzEFW6A',1),(27,'java多线程与高并发资料','java 多线程高并发','cxce','2019-01-31 21-06-46','https://pan.baidu.com/s/1SDAjqI95DllWiY3MI98zuw',1),(28,'java相关的面试题','java面试题','2zzb','2019-01-31 21-08-02','https://pan.baidu.com/s/1mMzEuBcN_Xpxbnao1wzgNg',1),(29,'spring boot教学视频','spring boot','07n3','2019-01-31 21-09-06','https://pan.baidu.com/s/1ihvBO4B87jkK8LSPo2eWxg',1),(30,'疯狂Android讲义资料','Android讲义','3obn','2019-01-31 21-10-00','https://pan.baidu.com/s/110sRbWwQU2FAF67V7di2uw',1),(31,'vc++ 6.0绿色版安装包','vc++ 6.0 绿色版','gm2c','2019-01-31 21-11-01','https://pan.baidu.com/s/1cWAoWlcY0xh7-hOUDloijA',1),(32,'java SE资料','java SE','pbaq','2019-01-31 21-11-53','https://pan.baidu.com/s/1qvzZfFTfu5RrnmcDtONg9A',1),(33,'eclipse jee安装包','eclipse jee安装包','ehcq','2019-01-31 21-12-46','https://pan.baidu.com/s/1MXI0XxjnSO7Oeq1eX41X0Q',1),(34,'疯狂java讲义第3版','疯狂java讲义','uwxw','2019-01-31 21-14-01','https://pan.baidu.com/s/16rHsaF54cj0GynkwHBKn-Q',1),(35,'轻量级java EE第四版','轻量级java EE','xgjb','2019-01-31 21-15-03','https://pan.baidu.com/s/1XgcrBHBlpVdxc8So98egDA',1),(36,'PPT模板','PPT','tbxj','2019-01-31 21-16-02','https://pan.baidu.com/s/1Z5TxAG-Rl0uiRleMVKAJ9w',1),(37,'Dreamweaver安装包','Dreamweaver安装包','hxai','2019-01-31 21-16-43','https://pan.baidu.com/s/1VckRrQg3xV45mpn_yOzuAw',1),(38,'MySQL安装包及教程','MySQL安装包','xohj','2019-01-31 21-17-45','https://pan.baidu.com/s/1OmG34WVVPLVqKyyO_AgbSw',1),(39,'Tomcat文件包','Tomcat','imhi','2019-01-31 21-18-26','https://pan.baidu.com/s/1_gGw7VJA26dDdL36dt4OFA',1),(40,'myeclipse安装包','myeclipse安装包','jntv','2019-01-31 21-19-50','https://pan.baidu.com/s/1WGYN9FLle3yFIJPLOxO8ag',1),(41,'Python课程','Python','r0yb','2019-01-31 21-20-45','https://pan.baidu.com/s/1anhdHijJinCED8RJw-hkoA',1),(42,'C#教学视','C#','pu40','2019-01-31 21-21-31','https://pan.baidu.com/s/1CcAdUXFCCaX-fW-S8xrNZg',1),(43,'经典javaEE PDF','经典javaEE','kne0','2019-01-31 21-22-40','https://pan.baidu.com/s/1nR7IsV_L-mrm5Z7RIlQ_KA',1),(44,'java EE必看','java EE必看','8pgx','2019-01-31 21-23-33','https://pan.baidu.com/s/1U2u9dJ6yapmDWkEgNBv22w',1);
/*!40000 ALTER TABLE `resource` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `syslog`
--

DROP TABLE IF EXISTS `syslog`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `syslog` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `create_time` varchar(255) DEFAULT NULL,
  `ip_string` varchar(255) DEFAULT NULL,
  `method` varchar(255) DEFAULT NULL,
  `operation` varchar(255) DEFAULT NULL,
  `params` varchar(255) DEFAULT NULL,
  `user_name` varchar(255) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `syslog`
--

LOCK TABLES `syslog` WRITE;
/*!40000 ALTER TABLE `syslog` DISABLE KEYS */;
/*!40000 ALTER TABLE `syslog` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `user`
--

DROP TABLE IF EXISTS `user`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `user` (
  `user_id` bigint(20) NOT NULL AUTO_INCREMENT,
  `count_id` varchar(255) DEFAULT NULL,
  `password` varchar(255) DEFAULT NULL,
  `picture_path` varchar(255) DEFAULT NULL,
  `user_name` varchar(255) DEFAULT NULL,
  PRIMARY KEY (`user_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `user`
--

LOCK TABLES `user` WRITE;
/*!40000 ALTER TABLE `user` DISABLE KEYS */;
/*!40000 ALTER TABLE `user` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `visitor`
--

DROP TABLE IF EXISTS `visitor`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `visitor` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `area` varchar(255) DEFAULT NULL,
  `browser` varchar(255) DEFAULT NULL,
  `ip` varchar(255) DEFAULT NULL,
  `ope_object` int(11) NOT NULL,
  `operate` varchar(255) DEFAULT NULL,
  `params` varchar(255) DEFAULT NULL,
  `status` int(11) NOT NULL,
  `system` varchar(255) DEFAULT NULL,
  `visit_time` varchar(255) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=76 DEFAULT CHARSET=utf8mb4;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `visitor`
--

LOCK TABLES `visitor` WRITE;
/*!40000 ALTER TABLE `visitor` DISABLE KEYS */;
INSERT INTO `visitor` VALUES (1,'无','CHROME','0:0:0:0:0:0:0:1',5,'查看博客','64',2,'WINDOWS_10','2019-02-14 15-46-57'),(2,'无','CHROME','0:0:0:0:0:0:0:1',6,'关键字搜索博客','搜索关键字为<span class=\"text-info\">#undefined#</span>的博客',2,'WINDOWS_10','2019-02-14 15-47-00'),(3,'无','CHROME','0:0:0:0:0:0:0:1',6,'关键字搜索博客','搜索关键字为<span class=\"text-info\">#undefined#</span>的博客',2,'WINDOWS_10','2019-02-14 15-47-07'),(4,'无','CHROME','0:0:0:0:0:0:0:1',6,'关键字搜索博客','搜索关键字为<span class=\"text-info\">#undefined#</span>的博客',2,'WINDOWS_10','2019-02-13 15-47-26'),(5,'无','CHROME','0:0:0:0:0:0:0:1',6,'关键字搜索博客','搜索关键字为<span class=\"text-info\">#undefined#</span>的博客',2,'WINDOWS_10','2019-02-13 15-47-42'),(6,'无','CHROME','0:0:0:0:0:0:0:1',6,'关键字搜索博客','搜索关键字为<span class=\"text-info\">#undefined#</span>的博客',2,'WINDOWS_10','2019-02-13 15-47-51'),(7,'无','CHROME','0:0:0:0:0:0:0:1',7,'关键字查询资源','none',2,'WINDOWS_10','2019-02-13 15-48-31'),(8,'无','CHROME','0:0:0:0:0:0:0:1',6,'关键字搜索博客','搜索关键字为<span class=\"text-info\">#mysql#</span>的博客',2,'WINDOWS_10','2019-02-13 15-48-39'),(9,'无','CHROME','0:0:0:0:0:0:0:1',7,'关键字查询资源','none',2,'WINDOWS_10','2019-02-13 15-48-42'),(10,'无','CHROME','0:0:0:0:0:0:0:1',7,'关键字查询资源','搜索关键字为<span class=\"text-info\">#java#</span>的资源',2,'WINDOWS_10','2019-02-14 15-48-50'),(11,'无','CHROME','0:0:0:0:0:0:0:1',1,'添加博客','新增了一篇博客',1,'WINDOWS_10','2019-02-14 15-51-25'),(12,'无','CHROME','0:0:0:0:0:0:0:1',0,'修改博客','将ID为<span class=\"text-info\">84</span>的博客<span class=\"text-success\">发表</span>',1,'WINDOWS_10','2019-02-14 15-52-10'),(13,'无','CHROME','0:0:0:0:0:0:0:1',0,'修改博客','将ID为<span class=\"text-info\">84</span>的博客<span class=\"text-success\">发表</span>',84,'WINDOWS_10','2019-02-14 15-54-39'),(16,'无','CHROME','0:0:0:0:0:0:0:1',1,'查询博客','关键字为##',1,'WINDOWS_10','2019-02-14 15-56-25'),(17,'无','CHROME','0:0:0:0:0:0:0:1',2,'查询博客类别','10',1,'WINDOWS_10','2019-02-14 15-56-26'),(18,'无','CHROME','0:0:0:0:0:0:0:1',0,'删除博客类别','删除的博客类别为<span class=\"text-info\">#unix#</span>',14,'WINDOWS_10','2019-02-14 15-56-34'),(20,'无','CHROME','0:0:0:0:0:0:0:1',0,'删除博客类别','删除的博客类别为<span class=\"text-info\">#unix#</span>',13,'WINDOWS_10','2019-02-14 15-56-37'),(22,'无','CHROME','0:0:0:0:0:0:0:1',2,'查询博客类别','10',1,'WINDOWS_10','2019-02-14 15-57-19'),(23,'无','CHROME','0:0:0:0:0:0:0:1',0,'删除博客类别','删除的博客类别为<span class=\"text-info\">#unix#</span>',15,'WINDOWS_10','2019-02-14 15-57-24'),(27,'无','CHROME','0:0:0:0:0:0:0:1',2,'添加博客类别','新增的博客类别为<span class=\"text-info\">#unix#</span>',1,'WINDOWS_10','2019-02-14 16-00-02'),(29,'无','CHROME','0:0:0:0:0:0:0:1',2,'删除博客类别','删除的博客类别为<span class=\"text-info\">#unix#</span>',1,'WINDOWS_10','2019-02-14 16-01-19'),(30,'无','CHROME','0:0:0:0:0:0:0:1',2,'删除博客类别','删除的博客类别为<span class=\"text-info\">#unix#</span>',1,'WINDOWS_10','2019-02-14 16-01-22'),(31,'无','CHROME','0:0:0:0:0:0:0:1',2,'删除博客类别','删除的博客类别为<span class=\"text-info\">#unix#</span>',1,'WINDOWS_10','2019-02-14 16-01-25'),(32,'无','CHROME','0:0:0:0:0:0:0:1',2,'添加博客类别','新增的博客类别为<span class=\"text-info\">#unix#</span>',1,'WINDOWS_10','2019-02-14 16-01-29'),(33,'无','CHROME','0:0:0:0:0:0:0:1',2,'添加博客类别','新增的博客类别为<span class=\"text-info\">#unix#</span>',1,'WINDOWS_10','2019-02-14 16-01-33'),(34,'无','CHROME','0:0:0:0:0:0:0:1',2,'添加博客类别','新增的博客类别为<span class=\"text-info\">#unix#</span>',1,'WINDOWS_10','2019-02-14 16-04-13'),(35,'无','CHROME','0:0:0:0:0:0:0:1',2,'删除博客类别','删除的博客类别为<span class=\"text-info\">#unix#</span>',1,'WINDOWS_10','2019-02-14 16-04-20'),(36,'无','CHROME','0:0:0:0:0:0:0:1',2,'删除博客类别','删除的博客类别为<span class=\"text-info\">#unix#</span>',1,'WINDOWS_10','2019-02-14 16-04-22'),(37,'无','CHROME','0:0:0:0:0:0:0:1',2,'修改博客类别','将类别名称<span class=\"text-info\">#Spring#</span>修改为<span class=\"text-info\">#Spring2#</span>',1,'WINDOWS_10','2019-02-14 16-05-02'),(38,'无','CHROME','0:0:0:0:0:0:0:1',0,'更新资源','更新了资源<span class=\"text-info\">#java EE必看#</span>',44,'WINDOWS_10','2019-02-14 16-05-40'),(39,'无','CHROME','0:0:0:0:0:0:0:1',3,'添加资源','新增的资源名称为<span class=\"text-info\">#是的发的是#</span>',1,'WINDOWS_10','2019-02-14 16-05-51'),(40,'无','CHROME','0:0:0:0:0:0:0:1',3,'更新资源','将资源<span class=\"text-info\">#是的发的是#</span>上架',1,'WINDOWS_10','2019-02-14 16-05-58'),(41,'无','CHROME','0:0:0:0:0:0:0:1',3,'更新资源','将资源<span class=\"text-info\">#是的发的是#</span>下架',1,'WINDOWS_10','2019-02-14 16-06-02'),(42,'无','CHROME','0:0:0:0:0:0:0:1',3,'删除资源','删除的资源为<span class=\"text-info\">#是的发的是#</span>',1,'WINDOWS_10','2019-02-14 16-06-05'),(43,'无','CHROME','0:0:0:0:0:0:0:1',0,'删除黑名单','将ip为<span class=\"text-info\">#0:0:0:0:0:0:0:1#</span>的用户<span class=\"text-success\">移出黑名单</span>',1,'WINDOWS_10','2019-02-14 16-35-12'),(44,'无','CHROME','0:0:0:0:0:0:0:1',0,'删除黑名单','将ip为<span class=\"text-info\">#0:0:0:0:0:0:0:1#</span>的用户<span class=\"text-success\">移出黑名单</span>',1,'WINDOWS_10','2019-02-14 16-35-16'),(45,'无','CHROME','0:0:0:0:0:0:0:1',5,'查看博客','60',2,'WINDOWS_10','2019-02-14 21-32-47'),(46,'无','CHROME','0:0:0:0:0:0:0:1',5,'查看博客','63',2,'WINDOWS_10','2019-02-14 21-49-49'),(47,'无','CHROME','192.168.1.101',5,'查看博客','63',2,'WINDOWS_10','2019-02-14 21-50-05'),(48,'无','CHROME','192.168.1.101',5,'查看博客','59',2,'WINDOWS_10','2019-02-14 21-50-20'),(49,'无','CHROME','0:0:0:0:0:0:0:1',6,'关键字搜索博客','搜索关键字为<span class=\"text-info\">#undefined#</span>的博客',2,'WINDOWS_10','2019-02-14 21-51-00'),(50,'无','CHROME','0:0:0:0:0:0:0:1',6,'关键字搜索博客','搜索关键字为<span class=\"text-info\">#undefined#</span>的博客',2,'WINDOWS_10','2019-02-14 21-51-28'),(51,'无','CHROME','0:0:0:0:0:0:0:1',6,'关键字搜索博客','搜索关键字为<span class=\"text-info\">#undefined#</span>的博客',2,'WINDOWS_10','2019-02-14 21-54-26'),(52,'无','CHROME','0:0:0:0:0:0:0:1',5,'查看博客','84',2,'WINDOWS_10','2019-02-14 22-05-59'),(53,'无','CHROME','0:0:0:0:0:0:0:1',5,'查看博客','74',2,'WINDOWS_10','2019-02-14 22-06-27'),(54,'无','CHROME','0:0:0:0:0:0:0:1',5,'查看博客','74',2,'WINDOWS_10','2019-02-14 22-06-52'),(55,'无','CHROME','0:0:0:0:0:0:0:1',5,'查看博客','74',2,'WINDOWS_10','2019-02-14 22-08-39'),(56,'无','CHROME','0:0:0:0:0:0:0:1',7,'关键字查询资源','none',2,'WINDOWS_10','2019-02-14 22-08-57'),(57,'无','CHROME','0:0:0:0:0:0:0:1',7,'关键字查询资源','none',2,'WINDOWS_10','2019-02-14 22-09-00'),(58,'无','CHROME','0:0:0:0:0:0:0:1',1,'修改博客','将ID为<span class=\"text-info\">84</span>的博客<span class=\"text-success\">发表</span>',1,'WINDOWS_10','2019-02-14 22-09-22'),(59,'无','CHROME','0:0:0:0:0:0:0:1',5,'查看博客','63',2,'WINDOWS_10','2019-02-15 22-09-27'),(60,'无','CHROME','0:0:0:0:0:0:0:1',2,'修改博客类别','将类别名称<span class=\"text-info\">#Spring2#</span>修改为<span class=\"text-info\">#Spring#</span>',1,'WINDOWS_10','2019-02-16 15-15-20'),(61,'无','CHROME','0:0:0:0:0:0:0:1',1,'添加博客','新增了一篇博客',1,'WINDOWS_10','2019-02-16 15-27-07'),(62,'无','CHROME','0:0:0:0:0:0:0:1',2,'修改博客类别','将类别名称<span class=\"text-info\">#Spring#</span>修改为<span class=\"text-info\">#Spring2#</span>',1,'WINDOWS_10','2019-02-16 15-53-41'),(63,'无','CHROME','0:0:0:0:0:0:0:1',2,'修改博客类别','将类别名称<span class=\"text-info\">#Spring2#</span>修改为<span class=\"text-info\">#Spring#</span>',1,'WINDOWS_10','2019-02-16 15-54-52'),(64,'无','CHROME','0:0:0:0:0:0:0:1',1,'查询博客','关键字为##',1,'WINDOWS_10','2019-02-16 15-55-08'),(65,'无','CHROME','0:0:0:0:0:0:0:1',1,'添加博客','新增了一篇博客',1,'WINDOWS_10','2019-02-16 15-55-55'),(66,'无','CHROME','0:0:0:0:0:0:0:1',1,'添加博客','新增了一篇博客',1,'WINDOWS_10','2019-02-16 15-57-44'),(67,'无','CHROME','0:0:0:0:0:0:0:1',7,'关键字查询资源','none',2,'WINDOWS_10','2019-02-16 16-00-01'),(68,'无','CHROME','0:0:0:0:0:0:0:1',7,'关键字查询资源','none',2,'WINDOWS_10','2019-02-16 16-00-02'),(69,'无','CHROME','0:0:0:0:0:0:0:1',1,'添加博客','新增了一篇博客',1,'WINDOWS_10','2019-02-16 16-22-22'),(70,'无','CHROME','0:0:0:0:0:0:0:1',1,'添加博客','新增了一篇博客',1,'WINDOWS_10','2019-02-16 16-24-53'),(71,'无','CHROME','0:0:0:0:0:0:0:1',5,'查看博客','52',2,'WINDOWS_10','2019-02-16 16-25-12'),(72,'无','CHROME','0:0:0:0:0:0:0:1',5,'查看博客','64',2,'WINDOWS_10','2019-02-16 16-25-21'),(73,'无','CHROME','0:0:0:0:0:0:0:1',5,'查看博客','48',2,'WINDOWS_10','2019-02-16 16-28-19'),(74,'无','CHROME','0:0:0:0:0:0:0:1',5,'查看博客','89',2,'WINDOWS_10','2019-02-16 16-29-57'),(75,'无','CHROME','0:0:0:0:0:0:0:1',5,'查看博客','52',2,'WINDOWS_10','2019-02-16 16-30-01');
/*!40000 ALTER TABLE `visitor` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `visitor_record`
--

DROP TABLE IF EXISTS `visitor_record`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `visitor_record` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `area` varchar(255) DEFAULT NULL,
  `browser` varchar(255) DEFAULT NULL,
  `ip` varchar(255) DEFAULT NULL,
  `status` int(11) NOT NULL,
  `system` varchar(255) DEFAULT NULL,
  `visit_num` bigint(20) NOT NULL,
  `visit_time` varchar(255) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8mb4;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `visitor_record`
--

LOCK TABLES `visitor_record` WRITE;
/*!40000 ALTER TABLE `visitor_record` DISABLE KEYS */;
INSERT INTO `visitor_record` VALUES (1,'无','CHROME','0:0:0:0:0:0:0:1',1,'WINDOWS_10',53,'2019-02-14 16-35-16'),(2,'无','CHROME','0:0:0:0:0:0:0:1',2,'WINDOWS_10',18,'2019-02-14 21-32-47'),(3,'无','CHROME','192.168.1.101',2,'WINDOWS_10',1,'2019-02-14 21-50-05');
/*!40000 ALTER TABLE `visitor_record` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Dumping events for database 'blogsystem'
--

--
-- Dumping routines for database 'blogsystem'
--
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2019-02-17 16:45:20
